package main



// Go

func Emulate6502( A *uint8, X *unit8, Y *unit8, SP *unit8, PC *uint16, SR *uint8, memory *byte[]) bool {
instruction := memory[PC & 0xFFFF]
if instruction == 0x00 { LL := memory[PC + 1]; readWord := memory[(0xFFFE)&0xFFFF] + (memory[((0xFFFE)+1)&0xFFFF]<<8); newSP := SP - 3; newPC := readWord; *SP = newSP; *PC = newPC; carry := SR&1; zero := (SR>>1)&1; interrupt := 0x1;decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = readWord;memory[(SP - 2)&0xFFFF] = SR | 0x10; memory[(SP - 1)&0xFFFF] = (PC + 2)&0xFF; memory[((SP - 1)+1)&0xFFFF] = ((PC + 2)>>8&0xFF; return true }
if instruction == 0x01 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x05 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x06 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte << 1; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x08 { newSP := SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&0xFFFF] = SR | 0x30; return true }
if instruction == 0x09 { LL := memory[PC + 1]; result := A | LL; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x0A { result := A << 1; newA := result; *A = newA; carry := A >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x0D { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A | readByte; newA := result; *A = newA; *PC = PC + 3; return true }
if instruction == 0x0E { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte << 1; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x10 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (negative-1)); *PC = newPC; *PC = PC + 2 + (LL & (negative-1));return true }
if instruction == 0x11 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x15 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x16 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := readByte << 1; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x18 { carry := 0x0;zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x19 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x1D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x1E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := readByte << 1; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x20 { LL := memory[PC + 1]; newSP := SP - 2; newPC := HHLL; *SP = newSP; *PC = newPC; *PC = HHLL;memory[(SP - 1)&0xFFFF] = (PC + 3)&0xFF; memory[((SP - 1)+1)&0xFFFF] = ((PC + 3)>>8&0xFF; return true }
if instruction == 0x21 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x24 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A & readByte; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := readByte >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x25 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x26 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := (readByte << 1) + carry; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x28 { readByte := memory[(SP + 1)&0xFFFF]; result := readByte; newSP := SP + 1; *SP = newSP; carry := result;zero := (result | -result) >> 7;interrupt := result >> 2;decimal := result >> 3;overflow := 0;negative := result >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x29 { LL := memory[PC + 1]; result := A & LL; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x2A { result := (A << 1) + carry; newA := result; *A = newA; carry := A >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x2C { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A & readByte; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := readByte >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x2D { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x2E { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := (readByte << 1) + carry; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x30 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (-negative)); *PC = newPC; *PC = PC + 2 + (LL & (-negative));return true }
if instruction == 0x31 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x35 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x36 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := (readByte << 1) + carry; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x38 { carry := 0x1;zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x39 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x3D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x3E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := (readByte << 1) + carry; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x40 { readByte := memory[(SP + 1)&0xFFFF]; readWord := memory[(SP + 3)&0xFFFF] + (memory[((SP + 3)+1)&0xFFFF]<<8); newSP := SP + 3; newPC := readWord; *SP = newSP; *PC = newPC; carry := result;zero := result >> 1;interrupt := result >> 2;decimal := result >> 3;overflow := 0;negative := result >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = readWord;return true }
if instruction == 0x41 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x45 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x46 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte >> 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x48 { newSP := SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&0xFFFF] = A; return true }
if instruction == 0x49 { LL := memory[PC + 1]; result := A ^ LL; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x4A { result := A >> 1; newA := result; *A = newA; carry := A;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x4C { newPC := HHLL; *PC = newPC; *PC = HHLL;return true }
if instruction == 0x4D { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x4E { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte >> 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x50 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (overflow-1)); *PC = newPC; *PC = PC + 2 + (LL & (overflow-1));return true }
if instruction == 0x51 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x55 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x56 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte >> 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x58 { carry := SR&1; zero := (SR>>1)&1; interrupt := 0x0;decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x59 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x5D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x5E { readByte := memory[(HHLL + X)&0xFFFF]; result := readByte >> 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x60 { readWord := memory[(SP + 1)&0xFFFF] + (memory[((SP + 1)+1)&0xFFFF]<<8); newSP := SP + 2; newPC := readWord; *SP = newSP; *PC = newPC; *PC = readWord;return true }
if instruction == 0x61 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x65 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x66 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := (readByte >> 1) + (carry << 7); carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x68 { readByte := memory[(SP + 1)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x69 { LL := memory[PC + 1]; result := A + LL + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x6A { result := (A >> 1) + (carry << 7); newA := result; *A = newA; carry := A;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x6C { readWord := memory[(HHLL)&0xFFFF] + (memory[((HHLL)+1)&0xFFFF]<<8); newPC := readWord; *PC = newPC; *PC = readWord;return true }
if instruction == 0x6D { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x6E { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := (readByte >> 1) + (carry << 7); carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x70 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (-overflow)); *PC = newPC; *PC = PC + 2 + (LL & (-overflow));return true }
if instruction == 0x71 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x75 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0x76 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := (readByte >> 1) + (carry << 7); carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x78 { carry := SR&1; zero := (SR>>1)&1; interrupt := 0x1;decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x79 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x7D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0x7E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := (readByte >> 1) + (carry << 7); carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0x81 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord)&0xFFFF] = A; return true }
if instruction == 0x84 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&0xFFFF] = Y; return true }
if instruction == 0x85 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&0xFFFF] = A; return true }
if instruction == 0x86 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&0xFFFF] = X; return true }
if instruction == 0x88 { result := Y - 1; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x8A { result := X; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x8C { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&0xFFFF] = Y; return true }
if instruction == 0x8D { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&0xFFFF] = A; return true }
if instruction == 0x8E { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&0xFFFF] = X; return true }
if instruction == 0x90 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (carry-1)); *PC = newPC; *PC = PC + 2 + (LL & (carry-1));return true }
if instruction == 0x91 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord + Y)&0xFFFF] = A; return true }
if instruction == 0x94 { LL := memory[PC + 1]; *PC = PC + 2; memory[((LL + X) & 0xFF)&0xFFFF] = Y; return true }
if instruction == 0x95 { LL := memory[PC + 1]; *PC = PC + 2; memory[((LL + X) & 0xFF)&0xFFFF] = A; return true }
if instruction == 0x96 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord + Y)&0xFFFF] = X; return true }
if instruction == 0x98 { result := Y; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0x99 { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL + Y)&0xFFFF] = A; return true }
if instruction == 0x9A { result := X; newSP := result; *SP = newSP; *PC = PC + 1; return true }
if instruction == 0x9D { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL + X)&0xFFFF] = A; return true }
if instruction == 0xA0 { LL := memory[PC + 1]; result := LL; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xA1 { zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xA2 { LL := memory[PC + 1]; result := LL; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xA4 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xA5 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xA6 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xA8 { result := A; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xA9 { LL := memory[PC + 1]; result := LL; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xAA { result := A; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xAC { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xAD { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xAE { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xB0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (-carry)); *PC = newPC; *PC = PC + 2 + (LL & (-carry));return true }
if instruction == 0xB1 { zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xB4 { readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xB5 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xB6 { readByte := memory[((LL + Y) & 0xFF)&0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xB8 { carry := SR&1; zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := 0x0;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xB9 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xBA { result := SP; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xBC { readByte := memory[(HHLL + X)&0xFFFF]; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xBD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xBE { readByte := memory[(HHLL + Y)&0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xC0 { LL := memory[PC + 1]; result := Y - LL; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xC1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xC4 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := Y - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xC5 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xC6 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte - 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0xC8 { result := Y + 1; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xC9 { LL := memory[PC + 1]; result := A - LL; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xCA { result := X - 1; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xCC { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := Y - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xCD { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xCE { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte - 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0xD0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (zero-1)); *PC = newPC; *PC = PC + 2 + (LL & (zero-1));return true }
if instruction == 0xD1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + YY)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xD5 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xD6 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte - 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0xD8 { carry := SR&1; zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := 0x0;overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xD9 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xDD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xDE { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := readByte - 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0xE0 { LL := memory[PC + 1]; result := X - LL; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xE1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xE4 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := X - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xE5 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xE6 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte + 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0xE8 { result := X + 1; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xE9 { LL := memory[PC + 1]; result := A - LL - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xEA { *PC = PC + 1; return true }
if instruction == 0xEC { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := X - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xED { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xEE { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte + 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0xF0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (-zero)); *PC = newPC; *PC = PC + 2 + (LL & (-zero));return true }
if instruction == 0xF1 { zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xF5 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }
if instruction == 0xF6 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte + 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }
if instruction == 0xF8 { carry := SR&1; zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := 0x1;overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xF9 { readByte := memory[(HHLL + Y)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }
if instruction == 0xFD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }
if instruction == 0xFE { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := readByte + 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }
return false
}


