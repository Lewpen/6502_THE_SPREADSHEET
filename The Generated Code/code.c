



// C


bool Emulate6502(uint8_t *pA, uint8_t *pX, uint8_t *pY, uint8_t *pSP, uint16_t *pPC, uint8_t *pSR, uint8_t *memory) {
	uint8_t A = *pA;
	uint8_t X = *pX;
	uint8_t Y = *pY;
	uint8_t SP = *pSP;
	uint16_t PC = *pPC;
	uint8_t SR = *pSR;
	uint16_t SPSP = SP;
	uint16_t XXXX = X;
	uint16_t YYYY = Y;
	uint8_t carry = SR&1;
	uint8_t zero = (SR>>1)&1;
	uint8_t overflow = (SR>>6)&1;
	uint8_t negative = (SR>>7)&1;
	uint16_t cccc = carry;
	uint16_t zzzz = zero&1;
	uint16_t vvvv = overflow&1;
	uint16_t nnnn = negative&1;
	uint8_t instruction = memory[PC & 0xFFFF];
	switch (instruction) {
	case 0x00: {
		uint16_t readWordAddress = 0xFFFE;
		uint16_t readWord = memory[readWordAddress] + (memory[(readWordAddress+1)&0xFFFF]<<8);
		uint8_t newSP = SP - 3;
		uint16_t newPC = (readWord)&0xFFFF;
		*pSP = newSP;
		*pPC = newPC;
		uint8_t newInterrupt = (0x1)&1;
		*pSR = (*pSR & (0b11111011)) + (newInterrupt<<2);
		*pPC = readWord;
		memory[(0x100 + (SPSP - 2) & 0x00FF)&0xFFFF] = SR | 0x10;
		memory[(0x100 + (SPSP - 1) & 0xFF)&0xFFFF] = (PC + 2)&0xFF;
		memory[((0x100 + (SPSP - 1) & 0xFF)+1)&0xFFFF] = (PC + 2)>>8&0xFF;
		return true;
	} break;
	case 0x01: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A | operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x05: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A | operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x06: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand << 1;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x08: {
		uint8_t newSP = SP - 1;
		*pSP = newSP;
		*pPC = PC + 1;
		memory[(0x100 + SPSP)&0xFFFF] = SR | 0x30;
		return true;
	} break;
	case 0x09: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = A | operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x0A: {
		uint8_t operand = A;
		uint8_t result = operand << 1;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x0D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A | operand;
		uint8_t newA = result;
		*pA = newA;
		*pPC = PC + 3;
		return true;
	} break;
	case 0x0E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand << 1;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x10: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t newPC = (PC + 2 + (LLLL & (nnnn-1)))&0xFFFF;
		*pPC = newPC;
		*pPC = PC + 2 + (LLLL & (nnnn-1));return true;
	} break;
	case 0x11: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord + YYYY;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A | operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x15: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A | operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x16: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand << 1;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x18: {
		uint8_t newCarry = (0x0)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		*pPC = PC + 1;
		return true;
	} break;
	case 0x19: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A | operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x1D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A | operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x1E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand << 1;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x20: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint8_t newSP = SP - 2;
		uint16_t newPC = (HHLL)&0xFFFF;
		*pSP = newSP;
		*pPC = newPC;
		*pPC = HHLL;
		memory[(0x100 + (SPSP - 1) & 0xFF)&0xFFFF] = (PC + 3)&0xFF;
		memory[((0x100 + (SPSP - 1) & 0xFF)+1)&0xFFFF] = (PC + 3)>>8&0xFF;
		return true;
	} break;
	case 0x21: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x24: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (operand >> 6)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (operand >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x25: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x26: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = (operand << 1) + carry;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x28: {
		uint16_t readByteAddress = 0x100 + ((SPSP + 1)&0x00FF);
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newSP = SP + 1;
		*pSP = newSP;
		uint8_t newCarry = (result)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newInterrupt = (result >> 2)&1;
		*pSR = (*pSR & (0b11111011)) + (newInterrupt<<2);
		uint8_t newDecimal = (result >> 3)&1;
		*pSR = (*pSR & (0b11110111)) + (newDecimal<<3);
		uint8_t newBreak = (0x0)&1;
		*pSR = (*pSR & (0b11101111)) + (newBreak<<4);
		uint8_t newOverflow = (result >> 6)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x29: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = A & operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x2A: {
		uint8_t operand = A;
		uint8_t result = (operand << 1) + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x2C: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (operand >> 6)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (operand >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x2D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x2E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = (operand << 1) + carry;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x30: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t newPC = (PC + 2 + (LLLL & (nnnn-1)))&0xFFFF;
		*pPC = newPC;
		*pPC = PC + 2 + (LLLL & (nnnn-1));return true;
	} break;
	case 0x31: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord + YYYY;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x35: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x36: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = (operand << 1) + carry;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x38: {
		uint8_t newCarry = (0x1)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newNegative = (0x1)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x39: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x3D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A & operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x3E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = (operand << 1) + carry;
		uint8_t newCarry = (operand >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x40: {
		uint16_t readByteAddress = 0x100 + (SPSP + 1) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint16_t readWordAddress = 0x200 + (SPSP + 2) & 0x00FF;
		uint16_t readWord = memory[readWordAddress] + (memory[(readWordAddress+1)&0xFFFF]<<8);
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newSP = SP + 2;
		uint16_t newPC = (readWord)&0xFFFF;
		*pSP = newSP;
		*pPC = newPC;
		uint8_t newCarry = (result)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (result >> 1)&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newInterrupt = (result >> 2)&1;
		*pSR = (*pSR & (0b11111011)) + (newInterrupt<<2);
		uint8_t newDecimal = (result >> 3)&1;
		*pSR = (*pSR & (0b11110111)) + (newDecimal<<3);
		uint8_t newBreak = (0x0)&1;
		*pSR = (*pSR & (0b11101111)) + (newBreak<<4);
		uint8_t newOverflow = (result >> 6)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = readWord;return true;
	} break;
	case 0x41: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A ^ operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x45: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A ^ operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x46: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand >> 1;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x48: {
		uint8_t operand = A;
		uint8_t newSP = SP - 1;
		*pSP = newSP;
		*pPC = PC + 1;
		memory[(0x100 + SPSP)&0xFFFF] = operand;
		return true;
	} break;
	case 0x49: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = A ^ operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x4A: {
		uint8_t operand = A;
		uint8_t result = operand >> 1;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x4C: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t newPC = (HHLL)&0xFFFF;
		*pPC = newPC;
		*pPC = HHLL;return true;
	} break;
	case 0x4D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A ^ operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x4E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand >> 1;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x50: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t newPC = (PC + 2 + (LLLL & (vvvv-1)))&0xFFFF;
		*pPC = newPC;
		*pPC = PC + 2 + (LLLL & (vvvv-1));return true;
	} break;
	case 0x51: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord + YYYY;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A ^ operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x55: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A ^ operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x56: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand >> 1;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x58: {
		uint8_t newInterrupt = (0x0)&1;
		*pSR = (*pSR & (0b11111011)) + (newInterrupt<<2);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x59: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A ^ operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x5D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A ^ operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x5E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand >> 1;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x60: {
		uint16_t readWordAddress = 0x200 + (SPSP + 1) & 0x00FF;
		uint16_t readWord = memory[readWordAddress] + (memory[(readWordAddress+1)&0xFFFF]<<8);
		uint8_t newSP = SP + 2;
		uint16_t newPC = (readWord)&0xFFFF;
		*pSP = newSP;
		*pPC = newPC;
		*pPC = readWord;return true;
	} break;
	case 0x61: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A + operand + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = ((result - A) >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x65: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A + operand + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = ((result - A) >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x66: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = (operand >> 1) + (carry << 7);
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x68: {
		uint16_t readByteAddress = 0x100 + (SPSP + 1) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x69: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = A + operand + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = ((result - A) >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x6A: {
		uint8_t operand = A;
		uint8_t result = (operand >> 1) + (carry << 7);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x6C: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readWordAddress = HHLL;
		uint16_t readWord = memory[readWordAddress] + (memory[(readWordAddress+1)&0xFFFF]<<8);
		uint16_t newPC = (readWord)&0xFFFF;
		*pPC = newPC;
		*pPC = readWord;return true;
	} break;
	case 0x6D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A + operand + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = ((result - A) >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x6E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = (operand >> 1) + (carry << 7);
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x70: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t newPC = (PC + 2 + (LLLL & (-vvvv)))&0xFFFF;
		*pPC = newPC;
		*pPC = PC + 2 + (LLLL & (-vvvv));return true;
	} break;
	case 0x71: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord + YYYY;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A + operand + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = ((result - A) >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x75: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A + operand + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = ((result - A) >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0x76: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = (operand >> 1) + (carry << 7);
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x78: {
		uint8_t newInterrupt = (0x1)&1;
		*pSR = (*pSR & (0b11111011)) + (newInterrupt<<2);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x79: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A + operand + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = ((result - A) >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x7D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A + operand + carry;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = ((result - A) >> 7)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0x7E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = (operand >> 1) + (carry << 7);
		uint8_t newCarry = (operand)&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x81: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint8_t operand = A;
		*pPC = PC + 2;
		memory[(zeroPageWord)&0xFFFF] = operand;
		return true;
	} break;
	case 0x84: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint8_t operand = Y;
		*pPC = PC + 2;
		memory[(LLLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x85: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint8_t operand = A;
		*pPC = PC + 2;
		memory[(LLLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x86: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint8_t operand = X;
		*pPC = PC + 2;
		memory[(LLLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x88: {
		uint8_t operand = Y;
		uint8_t result = operand - 1;
		uint8_t newY = result;
		*pY = newY;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x8A: {
		uint8_t operand = X;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x8C: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint8_t operand = Y;
		*pPC = PC + 3;
		memory[(HHLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x8D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint8_t operand = A;
		*pPC = PC + 3;
		memory[(HHLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x8E: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint8_t operand = X;
		*pPC = PC + 3;
		memory[(HHLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x90: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t newPC = (PC + 2 + (LLLL & (cccc-1)))&0xFFFF;
		*pPC = newPC;
		*pPC = PC + 2 + (LLLL & (cccc-1));return true;
	} break;
	case 0x91: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint8_t operand = A;
		*pPC = PC + 2;
		memory[(zeroPageWord + YYYY)&0xFFFF] = operand;
		return true;
	} break;
	case 0x94: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint8_t operand = Y;
		*pPC = PC + 2;
		memory[((LLLL + XXXX) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0x95: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint8_t operand = A;
		*pPC = PC + 2;
		memory[((LLLL + XXXX) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0x96: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = LL;
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint8_t operand = X;
		*pPC = PC + 2;
		memory[(zeroPageWord + YYYY)&0xFFFF] = operand;
		return true;
	} break;
	case 0x98: {
		uint8_t operand = Y;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0x99: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint8_t operand = A;
		*pPC = PC + 3;
		memory[(HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0x9A: {
		uint8_t operand = X;
		uint8_t result = operand;
		uint8_t newSP = result;
		*pSP = newSP;
		*pPC = PC + 1;
		return true;
	} break;
	case 0x9D: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint8_t operand = A;
		*pPC = PC + 3;
		memory[(HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0xA0: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = operand;
		uint8_t newY = result;
		*pY = newY;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xA1: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xA2: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = operand;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xA4: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newY = result;
		*pY = newY;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xA5: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xA6: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xA8: {
		uint8_t operand = A;
		uint8_t result = operand;
		uint8_t newY = result;
		*pY = newY;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xA9: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xAA: {
		uint8_t operand = A;
		uint8_t result = operand;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xAC: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newY = result;
		*pY = newY;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xAD: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xAE: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xB0: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t newPC = (PC + 2 + (LLLL & (-cccc)))&0xFFFF;
		*pPC = newPC;
		*pPC = PC + 2 + (LLLL & (-cccc));return true;
	} break;
	case 0xB1: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord + YYYY;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xB4: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newY = result;
		*pY = newY;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xB5: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xB6: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xB8: {
		uint8_t newOverflow = (0x0)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xB9: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xBA: {
		uint8_t operand = SP;
		uint8_t result = operand;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xBC: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newY = result;
		*pY = newY;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xBD: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newA = result;
		*pA = newA;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xBE: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xC0: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = Y - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xC1: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xC4: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = Y - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xC5: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xC6: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand - 1;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xC8: {
		uint8_t operand = Y;
		uint8_t result = operand + 1;
		uint8_t newY = result;
		*pY = newY;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xC9: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		int16_t result = (int16_t)A - (int16_t)operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xCA: {
		uint8_t operand = X;
		uint8_t result = operand - 1;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xCC: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = Y - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xCD: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xCE: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand - 1;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xD0: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t newPC = (PC + 2 + (LLLL & (zzzz-1)))&0xFFFF;
		*pPC = newPC;
		*pPC = PC + 2 + (LLLL & (zzzz-1));
		return true;
	} break;
	case 0xD1: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord + YYYY;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xD5: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xD6: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand - 1;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xD8: {
		uint8_t newDecimal = (0x0)&1;
		*pSR = (*pSR & (0b11110111)) + (newDecimal<<3);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xD9: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xDD: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xDE: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand - 1;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xE0: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = X - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xE1: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL + X);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand - (carry^1);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xE4: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = X - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xE5: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand - (carry^1);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xE6: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = LLLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand + 1;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xE8: {
		uint8_t operand = X;
		uint8_t result = operand + 1;
		uint8_t newX = result;
		*pX = newX;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xE9: {
		uint8_t LL = memory[PC + 1];
		uint8_t operand = LL;
		uint8_t result = A - operand - (carry^1);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xEA: {
		*pPC = PC + 1;
		return true;
	} break;
	case 0xEC: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = X - operand;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xED: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand - (carry^1);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xEE: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand + 1;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xF0: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t newPC = (PC + 2 + (LLLL & (-zzzz)))&0xFFFF;
		*pPC = newPC;
		*pPC = PC + 2 + (LLLL & (-zzzz));return true;
	} break;
	case 0xF1: {
		uint8_t LL = memory[PC + 1];
		uint8_t zeroPageWordAddress = (LL);
		uint16_t zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		uint16_t readByteAddress = zeroPageWord + YYYY;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand - (carry^1);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xF5: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand - (carry^1);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		return true;
	} break;
	case 0xF6: {
		uint8_t LL = memory[PC + 1];
		uint16_t LLLL = (uint16_t)(int8_t)LL;
		uint16_t readByteAddress = (LLLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand + 1;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xF8: {
		uint8_t newDecimal = (0x1)&1;
		*pSR = (*pSR & (0b11110111)) + (newDecimal<<3);
		*pPC = PC + 1;
		return true;
	} break;
	case 0xF9: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand - (carry^1);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xFD: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = A - operand - (carry^1);
		uint8_t newA = result;
		*pA = newA;
		uint8_t newCarry = (1 - (result >> 7))&1;
		*pSR = (*pSR & (0b11111110)) + newCarry;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		*pSR = (*pSR & (0b10111111)) + (newOverflow<<6);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		return true;
	} break;
	case 0xFE: {
		uint8_t LL = memory[PC + 1];
		uint16_t HH = memory[(PC+2)&0xFFFF];
		uint16_t HHLL = (uint16_t)(int8_t)LL + (HH<<8);
		uint16_t readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		uint8_t readByte = memory[readByteAddress];
		uint8_t operand = readByte;
		uint8_t result = operand + 1;
		uint8_t newZero = (1 - ((result | -result) >> 7))&1;
		*pSR = (*pSR & (0b11111101)) + (newZero<<1);
		uint8_t newNegative = (result >> 7)&1;
		*pSR = (*pSR & (0b01111111)) + (newNegative<<7);
		*pPC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	}
	return false;
}
