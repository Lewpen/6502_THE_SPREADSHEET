function Emulate6502(cpu, memory) {
	const A = cpu.A;
	const X = cpu.X;
	const Y = cpu.Y;
	const SP = cpu.SP;
	const PC = cpu.PC;
	const SR = cpu.SR;
	const SPSP = SP;
	const XXXX = X;
	const YYYY = Y;
	const carry = SR&1;
	const zero = (SR>>1)&1;
	const overflow = (SR>>6)&1;
	const negative = (SR>>7)&1;
	const cccc = carry;
	const zzzz = zero&1;
	const vvvv = overflow&1;
	const nnnn = negative&1;
	const instruction = memory[PC & 0xFFFF];
	switch (instruction) {
	case 0x00: {
		const readWordAddress = 0xFFFE;
		const readWord = memory[readWordAddress] + (memory[(readWordAddress+1)&0xFFFF]<<8);
		const newSP = SP - 3;
		const newPC = (readWord)&0xFFFF;
		cpu.SP = newSP;
		cpu.PC = newPC;
		const newInterrupt = (0x1)&1;
		cpu.SR = (cpu.SR & (0b11111011)) + (newInterrupt<<2);
		cpu.PC = readWord;
		memory[(0x100 + (SPSP - 2) & 0x00FF)&0xFFFF] = SR | 0x10;
		memory[(0x100 + (SPSP - 1) & 0xFF)&0xFFFF] = (PC + 2)&0xFF;
		memory[((0x100 + (SPSP - 1) & 0xFF)+1)&0xFFFF] = (PC + 2)>>8&0xFF;
		return true;
	} break;
	case 0x01: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A | operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x05: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A | operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x06: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand << 1;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x08: {
		const newSP = SP - 1;
		cpu.SP = newSP;
		cpu.PC = PC + 1;
		memory[(0x100 + SPSP)&0xFFFF] = SR | 0x30;
		return true;
	} break;
	case 0x09: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = A | operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x0A: {
		const operand = A;
		const result = operand << 1;
		const newA = result;
		cpu.A = newA;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x0D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A | operand;
		const newA = result;
		cpu.A = newA;
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x0E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand << 1;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x10: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const newPC = (PC + 2 + (LLLL & (nnnn-1)))&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = PC + 2 + (LLLL & (nnnn-1));
		return true;
	} break;
	case 0x11: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord + YYYY;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A | operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x15: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A | operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x16: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand << 1;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x18: {
		const newCarry = (0x0)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x19: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A | operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x1D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A | operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x1E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand << 1;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x20: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const newSP = SP - 2;
		const newPC = (HHLL)&0xFFFF;
		cpu.SP = newSP;
		cpu.PC = newPC;
		cpu.PC = HHLL;
		memory[(0x100 + (SPSP - 1) & 0xFF)&0xFFFF] = (PC + 3)&0xFF;
		memory[((0x100 + (SPSP - 1) & 0xFF)+1)&0xFFFF] = (PC + 3)>>8&0xFF;
		return true;
	} break;
	case 0x21: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x24: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (operand >> 6)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x25: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x26: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = (operand << 1) + carry;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x28: {
		const readByteAddress = 0x100 + ((SPSP + 1)&0x00FF);
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newSP = SP + 1;
		cpu.SP = newSP;
		const newCarry = (result)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newInterrupt = (result >> 2)&1;
		cpu.SR = (cpu.SR & (0b11111011)) + (newInterrupt<<2);
		const newDecimal = (result >> 3)&1;
		cpu.SR = (cpu.SR & (0b11110111)) + (newDecimal<<3);
		const newBreak = (0x0)&1;
		cpu.SR = (cpu.SR & (0b11101111)) + (newBreak<<4);
		const newOverflow = (result >> 6)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x29: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = A & operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x2A: {
		const operand = A;
		const result = (operand << 1) + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x2C: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (operand >> 6)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x2D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x2E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = (operand << 1) + carry;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x30: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const newPC = (PC + 2 + (LLLL & (nnnn-1)))&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = PC + 2 + (LLLL & (nnnn-1));
		return true;
	} break;
	case 0x31: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord + YYYY;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x35: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x36: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = (operand << 1) + carry;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x38: {
		const newCarry = (0x1)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newNegative = (0x1)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x39: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x3D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A & operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x3E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = (operand << 1) + carry;
		const newCarry = (operand >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x40: {
		const readByteAddress = 0x100 + (SPSP + 1) & 0x00FF;
		const readByte = memory[readByteAddress];
		const readWordAddress = 0x100 + (SPSP + 2) & 0x00FF;
		const readWord = memory[readWordAddress] + (memory[(readWordAddress+1)&0xFFFF]<<8);
		const operand = readByte;
		const result = operand;
		const newSP = SP + 2;
		const newPC = (readWord)&0xFFFF;
		cpu.SP = newSP;
		cpu.PC = newPC;
		const newCarry = (result)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (result >> 1)&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newInterrupt = (result >> 2)&1;
		cpu.SR = (cpu.SR & (0b11111011)) + (newInterrupt<<2);
		const newDecimal = (result >> 3)&1;
		cpu.SR = (cpu.SR & (0b11110111)) + (newDecimal<<3);
		const newBreak = (0x0)&1;
		cpu.SR = (cpu.SR & (0b11101111)) + (newBreak<<4);
		const newOverflow = (result >> 6)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = readWord;
		return true;
	} break;
	case 0x41: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A ^ operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x45: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A ^ operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x46: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand >> 1;
		const newA = result;
		cpu.A = newA;
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x48: {
		const operand = A;
		const newSP = SP - 1;
		cpu.SP = newSP;
		cpu.PC = PC + 1;
		memory[(0x100 + SPSP)&0xFFFF] = operand;
		return true;
	} break;
	case 0x49: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = A ^ operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x4A: {
		const operand = A;
		const result = operand >> 1;
		const newA = result;
		cpu.A = newA;
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x4C: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const newPC = (HHLL)&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = HHLL;
		return true;
	} break;
	case 0x4D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A ^ operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x4E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand >> 1;
		const newA = result;
		cpu.A = newA;
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x50: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const newPC = (PC + 2 + (LLLL & (vvvv-1)))&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = PC + 2 + (LLLL & (vvvv-1));
		return true;
	} break;
	case 0x51: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord + YYYY;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A ^ operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x55: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A ^ operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x56: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand >> 1;
		const newA = result;
		cpu.A = newA;
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x58: {
		const newInterrupt = (0x0)&1;
		cpu.SR = (cpu.SR & (0b11111011)) + (newInterrupt<<2);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x59: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A ^ operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x5D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A ^ operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x5E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand >> 1;
		const newA = result;
		cpu.A = newA;
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x60: {
		const readWordAddress = 0x100 + (SPSP + 1) & 0x00FF;
		const readWord = memory[readWordAddress] + (memory[(readWordAddress+1)&0xFFFF]<<8);
		const newSP = SP + 2;
		const newPC = (readWord)&0xFFFF;
		cpu.SP = newSP;
		cpu.PC = newPC;
		cpu.PC = readWord;
		return true;
	} break;
	case 0x61: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A + operand + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = ((result - A) >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x65: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A + operand + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = ((result - A) >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x66: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = (operand >> 1) + (carry << 7);
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x68: {
		const readByteAddress = 0x100 + (SPSP + 1) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x69: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = A + operand + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = ((result - A) >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x6A: {
		const operand = A;
		const result = (operand >> 1) + (carry << 7);
		const newA = result;
		cpu.A = newA;
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x6C: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readWordAddress = HHLL;
		const readWord = memory[readWordAddress] + (memory[(readWordAddress+1)&0xFFFF]<<8);
		const newPC = (readWord)&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = readWord;
		return true;
	} break;
	case 0x6D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A + operand + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = ((result - A) >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x6E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = (operand >> 1) + (carry << 7);
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x70: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const newPC = (PC + 2 + (LLLL & (-vvvv)))&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = PC + 2 + (LLLL & (-vvvv));
		return true;
	} break;
	case 0x71: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord + YYYY;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A + operand + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = ((result - A) >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x75: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A + operand + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = ((result - A) >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0x76: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = (operand >> 1) + (carry << 7);
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x78: {
		const newInterrupt = (0x1)&1;
		cpu.SR = (cpu.SR & (0b11111011)) + (newInterrupt<<2);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x79: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A + operand + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = ((result - A) >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x7D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A + operand + carry;
		const newA = result;
		cpu.A = newA;
		const newCarry = ((result - A) >> 7)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0x7E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = (operand >> 1) + (carry << 7);
		const newCarry = (operand)&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0x81: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const operand = A;
		cpu.PC = PC + 2;
		memory[(zeroPageWord)&0xFFFF] = operand;
		return true;
	} break;
	case 0x84: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const operand = Y;
		cpu.PC = PC + 2;
		memory[(LLLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x85: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const operand = A;
		cpu.PC = PC + 2;
		memory[(LLLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x86: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const operand = X;
		cpu.PC = PC + 2;
		memory[(LLLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x88: {
		const operand = Y;
		const result = operand - 1;
		const newY = result;
		cpu.Y = newY;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x8A: {
		const operand = X;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x8C: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const operand = Y;
		cpu.PC = PC + 3;
		memory[(HHLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x8D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const operand = A;
		cpu.PC = PC + 3;
		memory[(HHLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x8E: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const operand = X;
		cpu.PC = PC + 3;
		memory[(HHLL)&0xFFFF] = operand;
		return true;
	} break;
	case 0x90: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const newPC = (PC + 2 + (LLLL & (cccc-1)))&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = PC + 2 + (LLLL & (cccc-1));
		return true;
	} break;
	case 0x91: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const operand = A;
		cpu.PC = PC + 2;
		memory[(zeroPageWord + YYYY)&0xFFFF] = operand;
		return true;
	} break;
	case 0x94: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const operand = Y;
		cpu.PC = PC + 2;
		memory[((LLLL + XXXX) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0x95: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const operand = A;
		cpu.PC = PC + 2;
		memory[((LLLL + XXXX) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0x96: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const operand = X;
		cpu.PC = PC + 2;
		memory[((LLLL + YYYY) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0x98: {
		const operand = Y;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x99: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const operand = A;
		cpu.PC = PC + 3;
		memory[(HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0x9A: {
		const operand = X;
		const result = operand;
		const newSP = result;
		cpu.SP = newSP;
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0x9D: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const operand = A;
		cpu.PC = PC + 3;
		memory[(HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF)&0xFFFF] = operand;
		return true;
	} break;
	case 0xA0: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = operand;
		const newY = result;
		cpu.Y = newY;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xA1: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xA2: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = operand;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xA4: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newY = result;
		cpu.Y = newY;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xA5: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xA6: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xA8: {
		const operand = A;
		const result = operand;
		const newY = result;
		cpu.Y = newY;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xA9: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xAA: {
		const operand = A;
		const result = operand;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xAC: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newY = result;
		cpu.Y = newY;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xAD: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xAE: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xB0: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const newPC = (PC + 2 + (LLLL & (-cccc)))&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = PC + 2 + (LLLL & (-cccc));
		return true;
	} break;
	case 0xB1: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord + YYYY;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xB4: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newY = result;
		cpu.Y = newY;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xB5: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xB6: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xB8: {
		const newOverflow = (0x0)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xB9: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xBA: {
		const operand = SP;
		const result = operand;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xBC: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newY = result;
		cpu.Y = newY;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xBD: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newA = result;
		cpu.A = newA;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xBE: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xC0: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = Y - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xC1: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xC4: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = Y - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xC5: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xC6: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand - 1;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xC8: {
		const operand = Y;
		const result = operand + 1;
		const newY = result;
		cpu.Y = newY;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xC9: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = A - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xCA: {
		const operand = X;
		const result = operand - 1;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xCC: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = Y - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xCD: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xCE: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand - 1;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xD0: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const newPC = (PC + 2 + (LLLL & (zzzz-1)))&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = PC + 2 + (LLLL & (zzzz-1));
		return true;
	} break;
	case 0xD1: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord + YYYY;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xD5: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xD6: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand - 1;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xD8: {
		const newDecimal = (0x0)&1;
		cpu.SR = (cpu.SR & (0b11110111)) + (newDecimal<<3);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xD9: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xDD: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xDE: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand - 1;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xE0: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = X - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xE1: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL + X;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand - (carry^1);
		const newA = result;
		cpu.A = newA;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xE4: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = X - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xE5: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand - (carry^1);
		const newA = result;
		cpu.A = newA;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xE6: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = LLLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand + 1;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xE8: {
		const operand = X;
		const result = operand + 1;
		const newX = result;
		cpu.X = newX;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xE9: {
		const LL = memory[PC + 1];
		const operand = LL;
		const result = A - operand - (carry^1);
		const newA = result;
		cpu.A = newA;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xEA: {
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xEC: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = X - operand;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xED: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand - (carry^1);
		const newA = result;
		cpu.A = newA;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xEE: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand + 1;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xF0: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const newPC = (PC + 2 + (LLLL & (-zzzz)))&0xFFFF;
		cpu.PC = newPC;
		cpu.PC = PC + 2 + (LLLL & (-zzzz));
		return true;
	} break;
	case 0xF1: {
		const LL = memory[PC + 1];
		const zeroPageWordAddress = LL;
		const zeroPageWord = memory[zeroPageWordAddress] + (memory[(zeroPageWordAddress+1)&0xFF]<<8);
		const readByteAddress = zeroPageWord + YYYY;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand - (carry^1);
		const newA = result;
		cpu.A = newA;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xF5: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand - (carry^1);
		const newA = result;
		cpu.A = newA;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		return true;
	} break;
	case 0xF6: {
		const LL = memory[PC + 1];
		const LLLL = (LL << 24) >> 24;
		const readByteAddress = (LLLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand + 1;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 2;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	case 0xF8: {
		const newDecimal = (0x1)&1;
		cpu.SR = (cpu.SR & (0b11110111)) + (newDecimal<<3);
		cpu.PC = PC + 1;
		return true;
	} break;
	case 0xF9: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + YYYY) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand - (carry^1);
		const newA = result;
		cpu.A = newA;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xFD: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = A - operand - (carry^1);
		const newA = result;
		cpu.A = newA;
		const newCarry = (1 - (result >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111110)) + newCarry;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newOverflow = (((A ^ result) & (operand ^ result)) >> 7)&1;
		cpu.SR = (cpu.SR & (0b10111111)) + (newOverflow<<6);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		return true;
	} break;
	case 0xFE: {
		const LL = memory[PC + 1];
		const HH = memory[(PC+2)&0xFFFF];
		const HHLL = ((LL << 24) >> 24) + (HH<<8);
		const readByteAddress = HHLL & 0xFF00 + (HHLL + XXXX) & 0x00FF;
		const readByte = memory[readByteAddress];
		const operand = readByte;
		const result = operand + 1;
		const newZero = (1 - ((result | -result) >> 7))&1;
		cpu.SR = (cpu.SR & (0b11111101)) + (newZero<<1);
		const newNegative = (result >> 7)&1;
		cpu.SR = (cpu.SR & (0b01111111)) + (newNegative<<7);
		cpu.PC = PC + 3;
		memory[(readByteAddress)&0xFFFF] = result;
		return true;
	} break;
	}
	return false
}
