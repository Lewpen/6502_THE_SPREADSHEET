<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s148{background-color:#d0e0e3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s168{background-color:#f9cb9c;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s146{border-right:3px SOLID #000000;background-color:#d0e0e3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s62{border-left:none;background-color:#990000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s200{border-right:1px SOLID #000000;background-color:#cfe2f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s133{border-bottom:3px SOLID #000000;background-color:#c9daf8;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s192{border-right:3px SOLID #000000;background-color:#d9d2e9;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s136{border-bottom:3px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s194{background-color:#d9d2e9;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s53{border-left:none;border-right:none;background-color:#0b5394;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s20{border-left:none;background-color:#274e13;text-align:left;font-weight:bold;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:6pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s71{background-color:#3d85c6;text-align:left;font-weight:bold;color:#00ffff;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s14{background-color:#000000;text-align:left;font-weight:bold;color:#c9daf8;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s157{background-color:#d9ead3;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s214{border-bottom:3px SOLID #000000;background-color:#cfe2f3;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s126{background-color:#e6b8af;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s225{background-color:#f3f3f3;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s50{border-left:none;border-right:none;background-color:#0b5394;text-align:left;font-weight:bold;color:#6d9eeb;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s77{border-right:1px SOLID #000000;background-color:#674ea7;text-align:left;font-weight:bold;color:#00ffff;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s227{background-color:#f3f3f3;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s18{border-right:none;background-color:#274e13;text-align:left;font-weight:bold;color:#00ff00;font-family:Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s13{background-color:#000000;text-align:left;font-weight:bold;color:#cccccc;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s224{border-bottom:3px SOLID #000000;border-right:1px SOLID #000000;background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s74{background-color:#666666;text-align:left;font-weight:bold;color:#000000;font-family:"Courier New";font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s196{background-color:#cfe2f3;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s63{border-right:none;background-color:#0b5394;text-align:left;font-weight:bold;color:#c9daf8;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s99{border-right:none;background-color:#434343;text-align:left;font-weight:bold;color:#ffff00;font-family:docs-Lexend,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s112{background-color:#000000;text-align:left;font-weight:bold;color:#ffff00;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s6{background-color:#434343;text-align:left;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s186{border-bottom:3px SOLID #000000;border-right:1px SOLID #000000;background-color:#ead1dc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s170{border-right:3px SOLID #000000;background-color:#fce5cd;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s235{background-color:#434343;text-align:left;color:#ffff00;font-family:"Courier New";font-size:11pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s213{border-bottom:3px SOLID #000000;border-right:1px SOLID #000000;background-color:#d9d2e9;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s109{border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s21{border-right:3px SOLID #000000;background-color:#274e13;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s175{background-color:#ead1dc;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s98{border-left:none;background-color:#000000;text-align:left;font-weight:bold;color:#ffffff;font-family:docs-Lexend,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s42{background-color:#990000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s22{background-color:#434343;text-align:left;font-weight:bold;color:#cccccc;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s34{border-left:none;background-color:#351c75;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s234{background-color:#000000;text-align:left;color:#ffffff;font-family:"Courier New";font-size:11pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s118{border-right:1px SOLID #000000;background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s102{border-bottom:1px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s120{background-color:#c9daf8;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s35{background-color:#351c75;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s179{border-right:1px SOLID #000000;background-color:#ead1dc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s219{border-bottom:3px SOLID #000000;background-color:#ffe599;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s212{border-bottom:3px SOLID #000000;background-color:#d9d2e9;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s145{background-color:#d0e0e3;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s104{background-color:#000000;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s139{border-bottom:3px SOLID #000000;border-right:1px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s19{border-left:none;background-color:#274e13;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s216{border-bottom:3px SOLID #000000;background-color:#cfe2f3;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s163{border-bottom:3px SOLID #000000;background-color:#d9ead3;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s113{background-color:#ffe599;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s72{border-right:1px SOLID #000000;background-color:#3d85c6;text-align:left;font-weight:bold;color:#00ffff;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s101{background-color:#000000;text-align:left;font-weight:bold;color:#ffffff;font-family:docs-Lexend,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s117{background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s79{border-right:3px SOLID #000000;background-color:#b45f06;text-align:left;font-weight:bold;color:#f9cb9c;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s202{border-bottom:3px SOLID #000000;background-color:#f4cccc;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s58{border-left:none;border-right:none;background-color:#783f04;text-align:left;font-weight:bold;color:#e69138;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s37{border-right:none;background-color:#783f04;text-align:left;font-weight:bold;color:#f9cb9c;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s236{background-color:#434343;text-align:left;color:#00ffff;font-family:"Courier New";font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s106{background-color:#b7b7b7;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s149{border-right:1px SOLID #000000;background-color:#d0e0e3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s61{border-right:none;background-color:#990000;text-align:left;font-weight:bold;color:#f4cccc;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s67{border-right:3px SOLID #000000;background-color:#38761d;text-align:left;font-weight:bold;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s199{background-color:#cfe2f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s28{border-left:none;border-right:none;background-color:#434343;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s178{background-color:#ead1dc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s96{border-bottom:1px SOLID #000000;border-right:1px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s193{background-color:#d9d2e9;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s161{border-right:1px SOLID #000000;background-color:#d9ead3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s233{background-color:#434343;text-align:left;color:#00ff00;font-family:"Courier New";font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s156{background-color:#b6d7a8;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s60{border-left:none;border-right:none;background-color:#741b47;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s10{background-color:#000000;text-align:left;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s36{border-right:1px SOLID #000000;background-color:#351c75;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s185{border-bottom:3px SOLID #000000;background-color:#ead1dc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s207{border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s33{border-right:none;background-color:#351c75;text-align:left;font-weight:bold;color:#d9d2e9;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s223{border-bottom:3px SOLID #000000;background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s138{border-bottom:3px SOLID #000000;border-right:1px SOLID #000000;background-color:#c9daf8;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s209{border-bottom:3px SOLID #000000;background-color:#d9d2e9;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s11{border-right:none;background-color:#000000;text-align:left;font-weight:bold;color:#b6d7a8;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s172{background-color:#fce5cd;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s39{border-right:none;background-color:#741b47;text-align:left;font-weight:bold;color:#d9d2e9;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s44{border-right:1px SOLID #000000;background-color:#990000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s76{background-color:#674ea7;text-align:left;font-weight:bold;color:#d9d2e9;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s189{border-bottom:3px SOLID #000000;background-color:#a4c2f4;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s38{border-left:none;background-color:#783f04;text-align:left;font-weight:bold;color:#f9cb9c;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s195{border-right:1px SOLID #000000;background-color:#d9d2e9;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s124{border-right:1px SOLID #000000;background-color:#c9daf8;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s75{background-color:#999999;text-align:left;font-weight:bold;color:#000000;font-family:"Courier New";font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s166{border-bottom:3px SOLID #000000;background-color:#d9ead3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s81{background-color:#cc0000;text-align:left;font-weight:bold;color:#f4cccc;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s180{background-color:#a4c2f4;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s16{background-color:#000000;text-align:left;font-weight:bold;color:#f9cb9c;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s25{border-right:1px SOLID #000000;background-color:#0b5394;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s129{background-color:#e6b8af;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s7{background-color:#000000;text-align:left;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s91{border-bottom:1px SOLID #000000;background-color:#000000;text-align:left;font-weight:bold;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s135{border-bottom:3px SOLID #000000;background-color:#c9daf8;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s9{border-right:3px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s144{background-color:#a2c4c9;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s49{border-right:none;background-color:#434343;text-align:left;color:#cccccc;font-family:Arial;font-size:6pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s90{border-right:1px SOLID #000000;background-color:#000000;text-align:left;color:#999999;font-family:"docs-Liberation Sans",Arial;font-size:8pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s17{border-right:3px SOLID #000000;background-color:#000000;text-align:left;font-weight:bold;color:#f9cb9c;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s187{background-color:#434343;text-align:left;font-weight:bold;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s154{background-color:#f4cccc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s55{border-right:none;background-color:#351c75;text-align:left;font-weight:bold;color:#8e7cc3;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s162{border-bottom:3px SOLID #000000;background-color:#b6d7a8;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s182{border-bottom:3px SOLID #000000;background-color:#ead1dc;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s140{border-bottom:3px SOLID #000000;border-right:3px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s68{background-color:#000000;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s210{border-bottom:3px SOLID #000000;border-right:3px SOLID #000000;background-color:#d9d2e9;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s78{background-color:#b45f06;text-align:left;font-weight:bold;color:#f9cb9c;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s111{border-right:1px SOLID #000000;background-color:#efefef;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s32{background-color:#434343;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s8{background-color:#434343;text-align:left;color:#ffff00;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s45{background-color:#0b5394;text-align:left;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s56{border-left:none;border-right:none;background-color:#351c75;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s57{border-right:none;background-color:#783f04;text-align:left;font-weight:bold;color:#e69138;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s147{background-color:#d0e0e3;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s131{border-bottom:3px SOLID #000000;background-color:#000000;text-align:left;font-weight:bold;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s184{border-bottom:3px SOLID #000000;background-color:#ead1dc;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s208{border-bottom:3px SOLID #000000;background-color:#b4a7d6;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s230{background-color:#434343;text-align:left;font-weight:bold;color:#00ff00;font-family:docs-Lexend,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{border-left:none;border-right:none;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s94{border-bottom:1px SOLID #000000;border-right:3px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s158{border-right:3px SOLID #000000;background-color:#d9ead3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s107{background-color:#efefef;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s137{border-bottom:3px SOLID #000000;background-color:#c9daf8;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s159{background-color:#d9ead3;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s134{border-bottom:3px SOLID #000000;border-right:3px SOLID #000000;background-color:#c9daf8;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s150{background-color:#ea9999;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s205{border-bottom:3px SOLID #000000;background-color:#f4cccc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s87{border-right:3px SOLID #000000;background-color:#3d85c6;text-align:left;font-weight:bold;color:#c9daf8;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s181{border-bottom:3px SOLID #000000;background-color:#d5a6bd;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s43{background-color:#990000;text-align:left;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s132{border-bottom:3px SOLID #000000;background-color:#9fc5e8;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s188{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s215{border-bottom:3px SOLID #000000;border-right:3px SOLID #000000;background-color:#cfe2f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s222{border-bottom:3px SOLID #000000;background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s85{background-color:#3d85c6;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s152{border-right:3px SOLID #000000;background-color:#f4cccc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s30{border-left:none;background-color:#434343;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s143{border-bottom:3px SOLID #000000;background-color:#434343;text-align:left;font-weight:bold;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s26{border-right:none;background-color:#434343;text-align:left;font-weight:bold;color:#ffffff;font-family:Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s128{background-color:#e6b8af;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s66{background-color:#38761d;text-align:center;font-weight:bold;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s167{border-bottom:3px SOLID #000000;border-right:1px SOLID #000000;background-color:#d9ead3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s41{background-color:#741b47;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s127{border-right:3px SOLID #000000;background-color:#e6b8af;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s206{border-bottom:3px SOLID #000000;border-right:1px SOLID #000000;background-color:#f4cccc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s121{border-right:3px SOLID #000000;background-color:#c9daf8;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s24{background-color:#0b5394;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s69{border-right:3px SOLID #000000;background-color:#000000;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s177{background-color:#ead1dc;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s46{border-right:3px SOLID #000000;background-color:#0b5394;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s5{border-right:1px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s165{border-bottom:3px SOLID #000000;background-color:#d9ead3;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s114{background-color:#fff2cc;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s211{border-bottom:3px SOLID #000000;background-color:#d9d2e9;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s171{background-color:#fce5cd;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s217{border-bottom:3px SOLID #000000;background-color:#cfe2f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s142{background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s88{background-color:#000000;text-align:left;font-weight:bold;color:#00ffff;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s201{border-bottom:3px SOLID #000000;background-color:#ea9999;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s228{background-color:#f3f3f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s231{background-color:#434343;text-align:left;font-weight:bold;color:#ffff00;font-family:docs-Lexend,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s174{background-color:#d5a6bd;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s70{background-color:#666666;text-align:left;font-weight:bold;color:#efefef;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s153{background-color:#f4cccc;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s160{background-color:#d9ead3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s83{border-right:1px SOLID #000000;background-color:#cc0000;text-align:left;font-weight:bold;color:#f4cccc;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s229{border-right:1px SOLID #000000;background-color:#f3f3f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s51{border-left:none;background-color:#0b5394;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s40{border-left:none;background-color:#741b47;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s108{border-right:3px SOLID #000000;background-color:#efefef;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s65{background-color:#38761d;text-align:left;font-weight:bold;color:#00ff00;font-family:docs-Nunito,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s54{border-right:none;background-color:#434343;text-align:left;font-weight:bold;color:#cccccc;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{border-left:none;border-right:none;background-color:#000000;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s12{border-left:none;border-right:none;background-color:#000000;text-align:left;font-weight:bold;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:6pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s73{border-right:1px SOLID #000000;background-color:#000000;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s197{border-right:3px SOLID #000000;background-color:#cfe2f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s31{background-color:#666666;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s86{background-color:#3d85c6;text-align:left;font-weight:bold;color:#6d9eeb;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s92{border-bottom:1px SOLID #000000;background-color:#000000;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s220{border-bottom:3px SOLID #000000;background-color:#fff2cc;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s191{background-color:#d9d2e9;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s122{background-color:#c9daf8;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s23{background-color:#0b5394;text-align:left;font-weight:bold;color:#c9daf8;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s93{border-bottom:1px SOLID #000000;background-color:#000000;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s169{background-color:#fce5cd;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s218{border-bottom:3px SOLID #000000;border-right:1px SOLID #000000;background-color:#cfe2f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s237{background-color:#434343;text-align:left;color:#00ffff;font-family:"Courier New";font-size:11pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s52{border-right:none;background-color:#0b5394;text-align:left;font-weight:bold;color:#6d9eeb;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s80{background-color:#a64d79;text-align:left;font-weight:bold;color:#ead1dc;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s155{border-right:1px SOLID #000000;background-color:#f4cccc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s164{border-bottom:3px SOLID #000000;border-right:3px SOLID #000000;background-color:#d9ead3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s151{background-color:#f4cccc;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s204{border-bottom:3px SOLID #000000;background-color:#f4cccc;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s119{background-color:#9fc5e8;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s221{border-bottom:3px SOLID #000000;border-right:3px SOLID #000000;background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s198{background-color:#cfe2f3;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s190{background-color:#b4a7d6;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s82{background-color:#cc0000;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s203{border-bottom:3px SOLID #000000;border-right:3px SOLID #000000;background-color:#f4cccc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s89{background-color:#000000;text-align:left;color:#999999;font-family:"docs-Liberation Sans",Arial;font-size:8pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s123{background-color:#c9daf8;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s130{border-right:1px SOLID #000000;background-color:#e6b8af;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s48{border-left:none;background-color:#274e13;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s103{background-color:#000000;text-align:left;font-weight:bold;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s97{border-right:none;background-color:#434343;text-align:left;font-weight:bold;color:#00ff00;font-family:docs-Lexend,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s84{background-color:#3d85c6;text-align:left;font-weight:bold;color:#c9daf8;font-family:"docs-Roboto Mono",Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s115{border-right:3px SOLID #000000;background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s29{border-left:none;background-color:#666666;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s59{border-right:none;background-color:#741b47;text-align:left;font-weight:bold;color:#c27ba0;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s110{background-color:#efefef;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s173{border-right:1px SOLID #000000;background-color:#fce5cd;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{border-right:none;background-color:#000000;text-align:left;font-weight:bold;color:#00ff00;font-family:"docs-Roboto Mono",Arial;font-size:32pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s183{border-bottom:3px SOLID #000000;border-right:3px SOLID #000000;background-color:#ead1dc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s116{border-right:none;background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s226{border-right:3px SOLID #000000;background-color:#f3f3f3;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s64{border-left:none;background-color:#0b5394;text-align:left;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s27{border-left:none;border-right:none;background-color:#666666;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{border-left:none;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s15{background-color:#000000;text-align:left;font-weight:bold;color:#d9d2e9;font-family:"docs-Roboto Mono",Arial;font-size:16pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s141{background-color:#efefef;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s47{border-right:none;background-color:#274e13;text-align:left;font-weight:bold;color:#6aa84f;font-family:"docs-Roboto Mono",Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s176{border-right:3px SOLID #000000;background-color:#ead1dc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s100{border-right:none;background-color:#434343;text-align:left;font-weight:bold;color:#00ffff;font-family:docs-Lexend,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s105{background-color:#000000;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s232{background-color:#434343;text-align:left;font-weight:bold;color:#00ffff;font-family:docs-Lexend,Arial;font-size:9pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s95{border-bottom:1px SOLID #000000;background-color:#000000;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s125{background-color:#dd7e6b;text-align:center;font-weight:bold;color:#000000;font-family:"docs-Roboto Mono",Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header"></th><th id="0C0" style="width:100px;" class="column-headers-background">A</th><th id="0C1" style="width:100px;" class="column-headers-background">B</th><th id="0C2" style="width:100px;" class="column-headers-background">C</th><th id="0C3" style="width:100px;" class="column-headers-background">D</th><th id="0C4" style="width:24px;" class="column-headers-background">E</th><th class="freezebar-cell frozen-column-cell freezebar-vertical-handle"></th><th id="0C5" style="width:24px;" class="column-headers-background">F</th><th id="0C6" style="width:237px;" class="column-headers-background">G</th><th id="0C7" style="width:24px;" class="column-headers-background">H</th><th id="0C8" style="width:188px;" class="column-headers-background">I</th><th id="0C9" style="width:153px;" class="column-headers-background">J</th><th id="0C10" style="width:146px;" class="column-headers-background">K</th><th id="0C11" style="width:197px;" class="column-headers-background">L</th><th id="0C12" style="width:59px;" class="column-headers-background">M</th><th id="0C13" style="width:53px;" class="column-headers-background">N</th><th id="0C14" style="width:40px;" class="column-headers-background">O</th><th id="0C15" style="width:47px;" class="column-headers-background">P</th><th id="0C16" style="width:181px;" class="column-headers-background">Q</th><th id="0C17" style="width:105px;" class="column-headers-background">R</th><th id="0C18" style="width:143px;" class="column-headers-background">S</th><th id="0C19" style="width:95px;" class="column-headers-background">T</th><th id="0C20" style="width:79px;" class="column-headers-background">U</th><th id="0C21" style="width:63px;" class="column-headers-background">V</th><th id="0C22" style="width:235px;" class="column-headers-background">W</th><th id="0C23" style="width:97px;" class="column-headers-background">X</th><th id="0C24" style="width:167px;" class="column-headers-background">Y</th><th id="0C25" style="width:174px;" class="column-headers-background">Z</th><th id="0C26" style="width:194px;" class="column-headers-background">AA</th><th id="0C27" style="width:178px;" class="column-headers-background">AB</th><th id="0C28" style="width:24px;" class="column-headers-background">AC</th><th id="0C29" style="width:26px;" class="column-headers-background">AD</th><th id="0C30" style="width:162px;" class="column-headers-background">AE</th><th id="0C31" style="width:34px;" class="column-headers-background">AF</th><th id="0C32" style="width:175px;" class="column-headers-background">AG</th><th id="0C33" style="width:33px;" class="column-headers-background">AH</th><th id="0C34" style="width:200px;" class="column-headers-background">AI</th><th id="0C35" style="width:31px;" class="column-headers-background">AJ</th><th id="0C36" style="width:193px;" class="column-headers-background">AK</th><th id="0C37" style="width:24px;" class="column-headers-background">AL</th><th id="0C38" style="width:160px;" class="column-headers-background">AM</th><th id="0C39" style="width:192px;" class="column-headers-background">AN</th><th id="0C40" style="width:184px;" class="column-headers-background">AO</th><th id="0C41" style="width:136px;" class="column-headers-background">AP</th><th id="0C42" style="width:153px;" class="column-headers-background">AQ</th><th id="0C43" style="width:196px;" class="column-headers-background">AR</th><th id="0C44" style="width:43px;" class="column-headers-background">AS</th><th id="0C45" style="width:24px;" class="column-headers-background">AT</th><th id="0C46" style="width:156px;" class="column-headers-background">AU</th><th id="0C47" style="width:137px;" class="column-headers-background">AV</th><th id="0C48" style="width:146px;" class="column-headers-background">AW</th><th id="0C49" style="width:24px;" class="column-headers-background">AX</th><th id="0C50" style="width:141px;" class="column-headers-background">AY</th><th id="0C51" style="width:140px;" class="column-headers-background">AZ</th><th id="0C52" style="width:192px;" class="column-headers-background">BA</th><th id="0C53" style="width:54px;" class="column-headers-background">BB</th><th id="0C54" style="width:77px;" class="column-headers-background">BC</th><th id="0C55" style="width:75px;" class="column-headers-background">BD</th><th id="0C56" style="width:75px;" class="column-headers-background">BE</th><th id="0C57" style="width:79px;" class="column-headers-background">BF</th><th id="0C58" style="width:107px;" class="column-headers-background">BG</th><th id="0C59" style="width:154px;" class="column-headers-background">BH</th><th id="0C60" style="width:106px;" class="column-headers-background">BI</th><th id="0C61" style="width:145px;" class="column-headers-background">BJ</th><th id="0C62" style="width:102px;" class="column-headers-background">BK</th><th id="0C63" style="width:43px;" class="column-headers-background">BL</th><th id="0C64" style="width:24px;" class="column-headers-background">BM</th><th id="0C65" style="width:31px;" class="column-headers-background">BN</th><th id="0C66" style="width:32px;" class="column-headers-background">BO</th><th id="0C67" style="width:37px;" class="column-headers-background">BP</th><th id="0C68" style="width:100px;" class="column-headers-background">BQ</th><th id="0C69" style="width:100px;" class="column-headers-background">BR</th><th id="0C70" style="width:100px;" class="column-headers-background">BS</th><th id="0C71" style="width:32px;" class="column-headers-background">BT</th><th id="0C72" style="width:32px;" class="column-headers-background">BU</th><th id="0C73" style="width:100px;" class="column-headers-background">BV</th><th id="0C74" style="width:100px;" class="column-headers-background">BW</th><th id="0C75" style="width:100px;" class="column-headers-background">BX</th><th id="0C76" style="width:100px;" class="column-headers-background">BY</th><th id="0C77" style="width:100px;" class="column-headers-background">BZ</th><th id="0C78" style="width:100px;" class="column-headers-background">CA</th></tr></thead><tbody><tr style="height: 48px"><th id="0R0" style="height: 48px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 48px">1</div></th><td class="s0 softmerge" dir="ltr"><div class="softmerge-inner" style="width:2019px;left:-1px">6502 instructions in opcode byte value order with <span style="color:#6d9eeb;">emulation</span> and <span style="color:#d5a6bd;">reversability</span></div></td><td class="s1"></td><td class="s2"></td><td class="s1"></td><td class="s1"></td><td class="freezebar-cell"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s1"></td><td class="s3"></td><td class="s3"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s5"></td><td class="s4"></td><td class="s6"></td><td class="s7"></td><td class="s8"></td><td class="s7"></td><td class="s6"></td><td class="s7"></td><td class="s7"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td></tr><tr style="height: 43px"><th id="0R1" style="height: 43px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 43px">2</div></th><td class="s11 softmerge" dir="ltr"><div class="softmerge-inner" style="width:398px;left:-1px"><span style="color:#000000;">    </span><span style="text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#b6d7a8;"><a target="_blank" href="https://github.com/Lewpen/6502_THE_SPREADSHEET">https://github.com/Lewpen/6502_THE_SPREADSHEET</a></span></div></td><td class="s1"></td><td class="s12" dir="ltr"></td><td class="s3"></td><td class="s3"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s13" dir="ltr"></td><td class="s4"></td><td class="s14" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s5"></td><td class="s4"></td><td class="s6"></td><td class="s7"></td><td class="s6"></td><td class="s7"></td><td class="s6"></td><td class="s7"></td><td class="s7"></td><td class="s9"></td><td class="s15" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s5"></td><td class="s16" dir="ltr"></td><td class="s16" dir="ltr"></td><td class="s17" dir="ltr"></td><td class="s4"></td><td class="s15" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s18 softmerge"><div class="softmerge-inner" style="width:198px;left:-1px">Machine Code</div></td><td class="s19"></td><td class="s20" dir="ltr"></td><td class="s21"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s22" dir="ltr">Explanation</td><td class="s4"></td><td class="s23" dir="ltr">Emulation</td><td class="s24"></td><td class="s24"></td><td class="s25"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s25"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s25"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s25"></td><td class="s5"></td><td class="s26 softmerge" dir="ltr"><div class="softmerge-inner" style="width:395px;left:-1px">Code Generation Zone</div></td><td class="s27"></td><td class="s28"></td><td class="s29"></td><td class="s30"></td><td class="s31"></td><td class="s32"></td><td class="s32"></td><td class="s9"></td><td class="s33 softmerge" dir="ltr"><div class="softmerge-inner" style="width:350px;left:-1px">Erased Information</div></td><td class="s34"></td><td class="s34"></td><td class="s35"></td><td class="s35"></td><td class="s35"></td><td class="s36"></td><td class="s5"></td><td class="s37 softmerge" dir="ltr"><div class="softmerge-inner" style="width:291px;left:-1px">Reverse Instruction</div></td><td class="s38" dir="ltr"></td><td class="s38" dir="ltr"></td><td class="s4"></td><td class="s39 softmerge" dir="ltr"><div class="softmerge-inner" style="width:279px;left:-1px">Reverse Emulation</div></td><td class="s40"></td><td class="s40"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s9"></td><td class="s42"></td><td class="s42"></td><td class="s42"></td><td class="s42"></td><td class="s43"></td><td class="s44"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s45"></td><td class="s24"></td><td class="s24"></td><td class="s46"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s47 softmerge" dir="ltr"><div class="softmerge-inner" style="width:198px;left:-1px">Instructions</div></td><td class="s19"></td><td class="s48"></td><td class="s21"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s49 softmerge" dir="ltr"><div class="softmerge-inner" style="width:259px;left:-1px">Reference<br><span style="text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#cccccc;"><a target="_blank" href="https://www.masswerk.at/6502/6502_instruction_set.html#ASL">https://www.masswerk.at/6502/6502_instruction_set.html#ASL</a></span></div></td><td class="s3"></td><td class="s50 softmerge" dir="ltr"><div class="softmerge-inner" style="width:339px;left:-1px">Instruction Setup &amp; Memory Reads</div></td><td class="s51"></td><td class="s51"></td><td class="s25"></td><td class="s52 softmerge" dir="ltr"><div class="softmerge-inner" style="width:197px;left:-1px">Update Registers</div></td><td class="s53"></td><td class="s53"></td><td class="s51"></td><td class="s51"></td><td class="s52 softmerge" dir="ltr"><div class="softmerge-inner" style="width:246px;left:-1px">Update Flags</div></td><td class="s51"></td><td class="s51"></td><td class="s24"></td><td class="s24"></td><td class="s24"></td><td class="s25"></td><td class="s52 softmerge" dir="ltr"><div class="softmerge-inner" style="width:711px;left:-1px">Memory Write (up to 1 byte and 1 word; address and value for each)</div></td><td class="s53"></td><td class="s53"></td><td class="s51"></td><td class="s3"></td><td class="s54 softmerge" dir="ltr"><div class="softmerge-inner" style="width:628px;left:-1px">Each bright column is an emulator in a language</div></td><td class="s27" dir="ltr"></td><td class="s28" dir="ltr"></td><td class="s27" dir="ltr"></td><td class="s28" dir="ltr"></td><td class="s29" dir="ltr"></td><td class="s30" dir="ltr"></td><td class="s32" dir="ltr"></td><td class="s9"></td><td class="s55 softmerge" dir="ltr"><div class="softmerge-inner" style="width:670px;left:-1px">Trashes (need to be stored per instruction for reverse)</div></td><td class="s56"></td><td class="s56"></td><td class="s34"></td><td class="s34"></td><td class="s35"></td><td class="s36"></td><td class="s5"></td><td class="s57 softmerge" dir="ltr"><div class="softmerge-inner" style="width:460px;left:-1px">Bytes pushed onto the end of the reverse stack</div></td><td class="s58" dir="ltr"></td><td class="s58" dir="ltr"></td><td class="s3"></td><td class="s59 softmerge" dir="ltr"><div class="softmerge-inner" style="width:938px;left:-1px">Uses trashes and current state to undo what the instruction does (for stepping backwards)</div></td><td class="s60"></td><td class="s60"></td><td class="s60"></td><td class="s60"></td><td class="s60"></td><td class="s60"></td><td class="s60"></td><td class="s40"></td><td class="s40"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s41"></td><td class="s9"></td><td class="s61 softmerge"><div class="softmerge-inner" style="width:61px;left:-1px">Read</div></td><td class="s62"></td><td class="s62"></td><td class="s42"></td><td class="s43"></td><td class="s44"></td><td class="s63 softmerge"><div class="softmerge-inner" style="width:162px;left:-1px">Write</div></td><td class="s53"></td><td class="s51"></td><td class="s64"></td><td class="s24"></td><td class="s24"></td><td class="s46"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s65">Bytes</td><td class="s66">Name</td><td class="s66" dir="ltr">Cycles</td><td class="s67">Args</td><td class="s68"></td><td class="freezebar-cell"></td><td class="s69"></td><td class="s70" dir="ltr">Description of the instruction</td><td class="s68"></td><td class="s71" dir="ltr">zeroPageWordAddress =</td><td class="s71" dir="ltr">readByteAddress =</td><td class="s72" dir="ltr">readWordAddress =</td><td class="s72" dir="ltr">result (word) =</td><td class="s71" dir="ltr">A =</td><td class="s71" dir="ltr">X =</td><td class="s71" dir="ltr">Y =</td><td class="s71" dir="ltr">SP =</td><td class="s72" dir="ltr">PC =</td><td class="s71" dir="ltr">carry =</td><td class="s71" dir="ltr">zero =</td><td class="s71" dir="ltr">interrupt =</td><td class="s71" dir="ltr">decimal =</td><td class="s71" dir="ltr">break =</td><td class="s71" dir="ltr">overflow =</td><td class="s72" dir="ltr">negative =</td><td class="s71" dir="ltr">writeByteAddress</td><td class="s71" dir="ltr">writeByteValue</td><td class="s71" dir="ltr">writeWordAddress</td><td class="s72" dir="ltr">writeWordValue</td><td class="s73"></td><td class="s74" dir="ltr"></td><td class="s75" dir="ltr">// Go</td><td class="s74" dir="ltr"></td><td class="s75" dir="ltr">// C</td><td class="s74" dir="ltr"></td><td class="s75" dir="ltr">// JS</td><td class="s74" dir="ltr"></td><td class="s74" dir="ltr"></td><td class="s69"></td><td class="s76" dir="ltr">trashByteAddress</td><td class="s76" dir="ltr">trashWordAddress</td><td class="s76" dir="ltr">trashSR =</td><td class="s76" dir="ltr">trashRegister =</td><td class="s76" dir="ltr">trashPC =</td><td class="s76" dir="ltr">(individual flags)</td><td class="s77" dir="ltr"></td><td class="s73"></td><td class="s78" dir="ltr">Bytes</td><td class="s78" dir="ltr">Instruction Name</td><td class="s79" dir="ltr">Arguments</td><td class="s68"></td><td class="s80" dir="ltr">readByteAddress =</td><td class="s80" dir="ltr">readWordAddress =</td><td class="s80" dir="ltr">result =</td><td class="s80" dir="ltr">A =</td><td class="s80" dir="ltr">X =</td><td class="s80" dir="ltr">Y =</td><td class="s80" dir="ltr">SP =</td><td class="s80" dir="ltr">PC =</td><td class="s80" dir="ltr">SR =</td><td class="s80" dir="ltr">writeByteAddress =</td><td class="s80" dir="ltr">writeByte =</td><td class="s80" dir="ltr">writeWordAddress =</td><td class="s80" dir="ltr">writeWord =</td><td class="s80" dir="ltr"></td><td class="s69"></td><td class="s81">Regs</td><td class="s82"></td><td class="s82"></td><td class="s81">Mem</td><td class="s81">Flags</td><td class="s83">Stack</td><td class="s84">Regs</td><td class="s85"></td><td class="s84">Mem</td><td class="s84">Flags</td><td class="s86">Clear</td><td class="s86">Set</td><td class="s87">Stack</td><td class="s88" dir="ltr"></td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s89" dir="ltr">0</td><td class="s89" dir="ltr">1</td><td class="s89" dir="ltr">2</td><td class="s89" dir="ltr">3</td><td class="s89" dir="ltr">4</td><td class="freezebar-cell"></td><td class="s89" dir="ltr">5</td><td class="s89" dir="ltr">6</td><td class="s89" dir="ltr">7</td><td class="s89" dir="ltr">8</td><td class="s89" dir="ltr">9</td><td class="s89" dir="ltr">10</td><td class="s90" dir="ltr">11</td><td class="s89" dir="ltr">12</td><td class="s89" dir="ltr">13</td><td class="s89" dir="ltr">14</td><td class="s89" dir="ltr">15</td><td class="s90" dir="ltr">16</td><td class="s89" dir="ltr">17</td><td class="s89" dir="ltr">18</td><td class="s89" dir="ltr">19</td><td class="s89" dir="ltr">20</td><td class="s89" dir="ltr">21</td><td class="s89" dir="ltr">22</td><td class="s90" dir="ltr">23</td><td class="s89" dir="ltr">24</td><td class="s89" dir="ltr">25</td><td class="s89" dir="ltr">26</td><td class="s89" dir="ltr">27</td><td class="s89" dir="ltr">28</td><td class="s89" dir="ltr">55</td><td class="s89" dir="ltr"></td><td class="s89" dir="ltr"></td><td class="s89" dir="ltr"></td><td class="s89" dir="ltr"></td><td class="s89" dir="ltr"></td><td class="s89" dir="ltr"></td><td class="s89" dir="ltr"></td><td class="s89" dir="ltr">1</td><td class="s89" dir="ltr">29</td><td class="s89" dir="ltr">30</td><td class="s89" dir="ltr">31</td><td class="s89" dir="ltr">32</td><td class="s89" dir="ltr">33</td><td class="s89" dir="ltr">34</td><td class="s89" dir="ltr">35</td><td class="s89" dir="ltr">36</td><td class="s89" dir="ltr"></td><td class="s89" dir="ltr">52</td><td class="s89" dir="ltr">53</td><td class="s89" dir="ltr">54</td><td class="s89" dir="ltr">37</td><td class="s89" dir="ltr">38</td><td class="s89" dir="ltr">39</td><td class="s89" dir="ltr">40</td><td class="s89" dir="ltr">41</td><td class="s89" dir="ltr">42</td><td class="s89" dir="ltr">43</td><td class="s89" dir="ltr">44</td><td class="s89" dir="ltr">45</td><td class="s89" dir="ltr">46</td><td class="s89" dir="ltr">47</td><td class="s89" dir="ltr">48</td><td class="s89" dir="ltr">49</td><td class="s89" dir="ltr">50</td><td class="s89" dir="ltr">51</td><td class="s89" dir="ltr">2</td><td class="s89" dir="ltr">3</td><td class="s89" dir="ltr">4</td><td class="s89" dir="ltr">5</td><td class="s89" dir="ltr">6</td><td class="s89" dir="ltr">7</td><td class="s89" dir="ltr">8</td><td class="s89" dir="ltr">9</td><td class="s89" dir="ltr">10</td><td class="s89" dir="ltr">11</td><td class="s89" dir="ltr">12</td><td class="s89" dir="ltr">13</td><td class="s89" dir="ltr">14</td><td class="s89" dir="ltr">15</td></tr><tr><th style="height:3px;" class="freezebar-cell freezebar-horizontal-handle"></th><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s91" dir="ltr"></td><td class="s92" dir="ltr"></td><td class="s93" dir="ltr"></td><td class="s94" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s95"></td><td class="s95"></td><td class="s95" dir="ltr"></td><td class="s95"></td><td class="s95" dir="ltr"></td><td class="s96"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s95" dir="ltr"></td><td class="s96" dir="ltr"></td><td class="s95"></td><td class="s95"></td><td class="s95" dir="ltr"></td><td class="s95"></td><td class="s95"></td><td class="s95" dir="ltr"></td><td class="s96"></td><td class="s4" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s96" dir="ltr"></td><td class="s5"></td><td class="s95"></td><td class="s97 softmerge" dir="ltr"><div class="softmerge-inner" style="width:193px;left:-1px">func Emulate6502( A *uint8, X *unit8, Y *unit8, SP *unit8, PC *uint16, SR *uint8, memory *byte[]) bool {</div></td><td class="s98" dir="ltr"></td><td class="s99 softmerge" dir="ltr"><div class="softmerge-inner" style="width:205px;left:-1px">int Emulate6502( unsigned char *A, unsigned char *X, unsigned char *Y, unsigned char *SP, unsigned int *PC, unsigned char *SR, unsigned char *memory ) {</div></td><td class="s98" dir="ltr"></td><td class="s100 softmerge" dir="ltr"><div class="softmerge-inner" style="width:228px;left:-1px">function Emulate6502( cpu, memory ) {</div></td><td class="s98" dir="ltr"></td><td class="s101" dir="ltr"></td><td class="s95"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s96"></td><td class="s5"></td><td class="s4" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95" dir="ltr"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s102"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s102"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td><td class="s95"></td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s103" dir="ltr"></td><td class="s104" dir="ltr"></td><td class="s105" dir="ltr"></td><td class="s9" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4" dir="ltr"></td><td class="s4"></td><td class="s4" dir="ltr"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4" dir="ltr"></td><td class="s5" dir="ltr"></td><td class="s4"></td><td class="s95"></td><td class="s4" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s4" dir="ltr"></td><td class="s5"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s5" dir="ltr"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge" dir="ltr"><div class="softmerge-inner" style="width:193px;left:-1px">  instruction := memory[PC &amp; 0xFFFF]</div></td><td class="s98" dir="ltr"></td><td class="s99 softmerge" dir="ltr"><div class="softmerge-inner" style="width:205px;left:-1px">  unsigned char instruction = memory[PC &amp; 0xFFFF];</div></td><td class="s98" dir="ltr"></td><td class="s100 softmerge" dir="ltr"><div class="softmerge-inner" style="width:228px;left:-1px">  const A = cpu.A, X = cpu.X, Y = cpu.Y, SP = cpu.SP, PC = cpu.PC, SR = <span style="text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;"><a target="_blank" href="http://cpu.sr/">cpu.SR</a></span></div></td><td class="s98" dir="ltr"></td><td class="s101" dir="ltr"></td><td class="s4"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s5"></td><td class="s5"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s103" dir="ltr">00 LL</td><td class="s106" dir="ltr">BRK</td><td class="s107" dir="ltr">7</td><td class="s108" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s109 softmerge" dir="ltr"><div class="softmerge-inner" style="width:258px;left:-1px">Force Break, LL = reason. Pushes PC and SR then jumps to the address stored in the word at 0xFFFE</div></td><td class="s3"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110" dir="ltr">0xFFFE</td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SP - 3</td><td class="s111" dir="ltr">readWord</td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">0x1</td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s110" dir="ltr">SP - 2</td><td class="s110" dir="ltr">SR | 0x10</td><td class="s110" dir="ltr">SP - 1</td><td class="s111" dir="ltr">PC + 2</td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x00 { LL := memory[PC + 1]; readWord := memory[(0xFFFE)&amp;0xFFFF] + (memory[((0xFFFE)+1)&amp;0xFFFF]&lt;&lt;8); newSP := SP - 3; newPC := readWord; *SP = newSP; *PC = newPC; carry := SR&amp;1; zero := (SR&gt;&gt;1)&amp;1; interrupt := 0x1;decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = readWord;memory[(SP - 2)&amp;0xFFFF] = SR | 0x10; memory[(SP - 1)&amp;0xFFFF] = (PC + 2)&amp;0xFF; memory[((SP - 1)+1)&amp;0xFFFF] = ((PC + 2)&gt;&gt;8&amp;0xFF; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x00 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int readWord := memory[(0xFFFE)&amp;0xFFFF] + (memory[((0xFFFE)+1)&amp;0xFFFF]&lt;&lt;8); unsigned char newSP = SP - 3; unsigned int newPC = (readWord)&amp;0xFFFF; *SP = newSP; *PC = newPC; unsigned char carry = SR&amp;1; unsigned char zero = (SR&gt;&gt;1)&amp;1; unsigned char interrupt = 0x1;unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = readWord;memory[(SP - 2)&amp;0xFFFF] = SR | 0x10; memory[(SP - 1)&amp;0xFFFF] = (PC + 2)&amp;0xFF; memory[((SP - 1)+1)&amp;0xFFFF] = ((PC + 2)&gt;&gt;8&amp;0xFF; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x00 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readWord = memory[(0xFFFE)&amp;0xFFFF] + (memory[((0xFFFE)+1)&amp;0xFFFF]&lt;&lt;8); const newSP = SP - 3; const newPC = (readWord)&amp;0xFFFF; cpu.SP = newSP; cpu.PC = newPC; const carry = SR&amp;1; const zero = (SR&gt;&gt;1)&amp;1; const interrupt = 0x1;const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = readWord;memory[(SP - 2)&amp;0xFFFF] = SR | 0x10; memory[(SP - 1)&amp;0xFFFF] = (PC + 2)&amp;0xFF; memory[((SP - 1)+1)&amp;0xFFFF] = ((PC + 2)&gt;&gt;8&amp;0xFF; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr">SP - 2</td><td class="s110" dir="ltr">SP - 1</td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">interrupt</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">BB LL HH SS 00</td><td class="s110" dir="ltr">UNBRK</td><td class="s108" dir="ltr">$BB, $HHLL, $SS</td><td class="s4"></td><td class="s110" dir="ltr">SP + 1</td><td class="s110" dir="ltr">SP + 2</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">SP + 3</td><td class="s110" dir="ltr">readWord</td><td class="s110" dir="ltr">SS</td><td class="s110" dir="ltr">SP + 1</td><td class="s110" dir="ltr">BB</td><td class="s110" dir="ltr">SP + 2</td><td class="s110" dir="ltr">HHLL</td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s103" dir="ltr">01 LL</td><td class="s113" dir="ltr">ORA</td><td class="s114" dir="ltr">6</td><td class="s115" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s116 softmerge" dir="ltr"><div class="softmerge-inner" style="width:258px;left:-1px">Performs bitwise OR between A register and the byte whose address is in the word in zero page at (LL + X), storing result in A</div></td><td class="s3"></td><td class="s117" dir="ltr">LL + X</td><td class="s117" dir="ltr">zeroPageWord</td><td class="s117" dir="ltr"></td><td class="s118" dir="ltr">A | readByte</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s118"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x01 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x01 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x01 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 01</td><td class="s117" dir="ltr">UNORA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">RR</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">SS</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr">X</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s103" dir="ltr">05 LL</td><td class="s113" dir="ltr">ORA</td><td class="s114" dir="ltr">3</td><td class="s115" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s116 softmerge" dir="ltr"><div class="softmerge-inner" style="width:258px;left:-1px">Performs bitwise OR between A register and the byte in zero LL, storing result in A</div></td><td class="s3"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">LL</td><td class="s117" dir="ltr"></td><td class="s118" dir="ltr">A | readByte</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s118"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x05 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x05 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x05 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 05</td><td class="s117" dir="ltr">UNORA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">RR</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">SS</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">$LL</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s103" dir="ltr">06 LL</td><td class="s119" dir="ltr">ASL</td><td class="s120" dir="ltr">5</td><td class="s121" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122" dir="ltr"></td><td class="s4"></td><td class="s123"></td><td class="s123" dir="ltr">LL</td><td class="s123" dir="ltr"></td><td class="s124" dir="ltr">readByte &lt;&lt; 1</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr"></td><td class="s124"></td><td class="s123" dir="ltr">readByte &gt;&gt; 7</td><td class="s123" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">result &gt;&gt; 7</td><td class="s123" dir="ltr">readByteAddress</td><td class="s123" dir="ltr">result</td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x06 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := readByte &lt;&lt; 1; carry := readByte &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x06 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = readByte &lt;&lt; 1; unsigned char carry = readByte &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x06 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = readByte &lt;&lt; 1; const carry = readByte &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SR</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">carry, zero, negative</td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">SS 06</td><td class="s123" dir="ltr">UNASL</td><td class="s121" dir="ltr">$SS</td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s121" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s103" dir="ltr">08</td><td class="s125" dir="ltr">PHP</td><td class="s126" dir="ltr">3</td><td class="s127"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s128"></td><td class="s4"></td><td class="s129" dir="ltr"></td><td class="s129"></td><td class="s129"></td><td class="s130"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129" dir="ltr">SP - 1</td><td class="s130"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s130"></td><td class="s129" dir="ltr">SP</td><td class="s129" dir="ltr">SR | 0x30</td><td class="s129"></td><td class="s130"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x08 { newSP := SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&amp;0xFFFF] = SR | 0x30; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x08 ) { unsigned char newSP = SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&amp;0xFFFF] = SR | 0x30; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x08 ) { const newSP = SP - 1; cpu.SP = newSP; cpu.PC = PC + 1; memory[(SP)&amp;0xFFFF] = SR | 0x30; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s129" dir="ltr">writeByteAddress</td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s130"></td><td class="s5"></td><td class="s112" dir="ltr">BB 08</td><td class="s129">UNPHP</td><td class="s127" dir="ltr">$BB</td><td class="s4"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s9"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s127"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s103" dir="ltr">09 LL</td><td class="s113" dir="ltr">ORA</td><td class="s114" dir="ltr">2</td><td class="s115" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s116 softmerge" dir="ltr"><div class="softmerge-inner" style="width:258px;left:-1px">Performs bitwise OR between A register and the value LL, storing result in A</div></td><td class="s3"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s118" dir="ltr">A | LL</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x09 { LL := memory[PC + 1]; result := A | LL; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x09 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = A | LL; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x09 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = A | LL; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 09</td><td class="s117" dir="ltr">UNORA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s103" dir="ltr">0A</td><td class="s119" dir="ltr">ASL</td><td class="s120" dir="ltr">2</td><td class="s121" dir="ltr">A</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122"></td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">A &lt;&lt; 1</td><td class="s123" dir="ltr">result</td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr"></td><td class="s124"></td><td class="s123" dir="ltr">A &gt;&gt; 7</td><td class="s123" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">result &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x0A { result := A &lt;&lt; 1; newA := result; *A = newA; carry := A &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x0A ) { unsigned int result = A &lt;&lt; 1; unsigned char newA = result; *A = newA; unsigned char carry = A &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x0A ) { const result = A &lt;&lt; 1; const newA = result; cpu.A = newA; const carry = A &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SR</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">carry, zero, negative</td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">SS 0A</td><td class="s123" dir="ltr">UNASL</td><td class="s121" dir="ltr">$SS</td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">(carry &lt;&lt; 7) | (A &gt;&gt; 1)</td><td class="s123" dir="ltr">result</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr">A</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">A</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s121" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s103" dir="ltr">0D LL HH</td><td class="s113" dir="ltr">ORA</td><td class="s114" dir="ltr">4</td><td class="s115" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s116 softmerge" dir="ltr"><div class="softmerge-inner" style="width:258px;left:-1px">Performs bitwise OR between A register and the byte at address HHLL, storing result in A</div></td><td class="s3"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">HHLL</td><td class="s117"></td><td class="s118" dir="ltr">A | readByte</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s118"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x0D { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := A | readByte; newA := result; *A = newA; *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x0D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x0D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 0D</td><td class="s117" dir="ltr">UNORA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s131" dir="ltr">0E LL HH</td><td class="s132" dir="ltr">ASL</td><td class="s133" dir="ltr">6</td><td class="s134" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s135"></td><td class="s136"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">HHLL</td><td class="s137"></td><td class="s138" dir="ltr">readByte &lt;&lt; 1</td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s137" dir="ltr"></td><td class="s138" dir="ltr"></td><td class="s137" dir="ltr">readByte &gt;&gt; 7</td><td class="s137" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s138" dir="ltr">result &gt;&gt; 7</td><td class="s137" dir="ltr">readByteAddress</td><td class="s137" dir="ltr">result</td><td class="s137"></td><td class="s138"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x0E { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := readByte &lt;&lt; 1; carry := readByte &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x0E ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = readByte &lt;&lt; 1; unsigned char carry = readByte &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x0E ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = readByte &lt;&lt; 1; const carry = readByte &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s137"></td><td class="s137"></td><td class="s137" dir="ltr">SR</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">carry, zero, negative</td><td class="s138"></td><td class="s139"></td><td class="s112" dir="ltr">SS 0E</td><td class="s137" dir="ltr">UNASL</td><td class="s134" dir="ltr">$SS</td><td class="s136"></td><td class="s137" dir="ltr">HHLL</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">(carry &lt;&lt; 7) | (readByte &gt;&gt; 1)</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">HHLL</td><td class="s137" dir="ltr">result</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s140"></td><td class="s137" dir="ltr">A</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">A</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s134" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s103" dir="ltr">10 LL</td><td class="s106" dir="ltr">BPL</td><td class="s107" dir="ltr">2**</td><td class="s108" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141" dir="ltr"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s111" dir="ltr">PC + 2 + (LL &amp; (negative-1))</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x10 { LL := memory[PC + 1]; newPC := PC + 2 + (LL &amp; (negative-1)); *PC = newPC; *PC = PC + 2 + (LL &amp; (negative-1));return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x10 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int newPC = (PC + 2 + (LL &amp; (negative-1)))&amp;0xFFFF; *PC = newPC; *PC = PC + 2 + (LL &amp; (negative-1));return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x10 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const newPC = (PC + 2 + (LL &amp; (negative-1)))&amp;0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL &amp; (negative-1));return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">10</td><td class="s110">UNBPL</td><td class="s108"></td><td class="s4"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s108"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s103" dir="ltr">11 LL</td><td class="s113" dir="ltr">ORA</td><td class="s114" dir="ltr">5*</td><td class="s115" dir="ltr">($LL), Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr">LL</td><td class="s117" dir="ltr">zeroPageWord + Y</td><td class="s117"></td><td class="s118" dir="ltr">A | readByte</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x11 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord + Y)&amp;0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x11 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x11 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 11</td><td class="s117" dir="ltr">UNORA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr">Y</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s103" dir="ltr">15 LL</td><td class="s113" dir="ltr">ORA</td><td class="s114" dir="ltr">4</td><td class="s115" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s117"></td><td class="s118" dir="ltr">A | readByte</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x15 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x15 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x15 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 15</td><td class="s117" dir="ltr">UNORA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr">X</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s103" dir="ltr">16 LL</td><td class="s119" dir="ltr">ASL</td><td class="s120" dir="ltr">6</td><td class="s121" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122"></td><td class="s4"></td><td class="s123" dir="ltr">LL + X</td><td class="s123" dir="ltr">zeroPageWord</td><td class="s123"></td><td class="s124" dir="ltr">readByte &lt;&lt; 1</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr"></td><td class="s124"></td><td class="s123" dir="ltr">readByte &gt;&gt; 7</td><td class="s123" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">result &gt;&gt; 7</td><td class="s123" dir="ltr">readByteAddress</td><td class="s123" dir="ltr">result</td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x16 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := readByte &lt;&lt; 1; carry := readByte &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x16 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = readByte &lt;&lt; 1; unsigned char carry = readByte &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x16 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = readByte &lt;&lt; 1; const carry = readByte &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SR</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">carry, zero, negative</td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">SS 16</td><td class="s123" dir="ltr">UNASL</td><td class="s121" dir="ltr">$SS</td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr">A</td><td class="s123" dir="ltr">X</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">A</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s121" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s103" dir="ltr">18</td><td class="s106" dir="ltr">CLC</td><td class="s107" dir="ltr">2</td><td class="s108"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s110" dir="ltr">0x0</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x18 { carry := 0x0;zero := (SR&gt;&gt;1)&amp;1; interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x18 ) { unsigned char carry = 0x0;unsigned char zero = (SR&gt;&gt;1)&amp;1; unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x18 ) { const carry = 0x0;const zero = (SR&gt;&gt;1)&amp;1; const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">carry</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">SS 18</td><td class="s110" dir="ltr">UNCLC</td><td class="s108" dir="ltr"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s103" dir="ltr">19 LL HH</td><td class="s113" dir="ltr">ORA</td><td class="s114" dir="ltr">4*</td><td class="s115" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117"></td><td class="s117" dir="ltr">HHLL + Y</td><td class="s117"></td><td class="s118" dir="ltr">A | readByte</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x19 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&amp;0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x19 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + Y)&amp;0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x19 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + Y)&amp;0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 19</td><td class="s117" dir="ltr">UNORA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr">Y</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s103" dir="ltr">1D LL HH</td><td class="s113" dir="ltr">ORA</td><td class="s114" dir="ltr">4*</td><td class="s115" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117"></td><td class="s117" dir="ltr">HHLL + X</td><td class="s117"></td><td class="s118" dir="ltr">A | readByte</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x1D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x1D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x1D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 1D</td><td class="s117" dir="ltr">UNORA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s143" dir="ltr">1E LL HH</td><td class="s132" dir="ltr">ASL</td><td class="s133" dir="ltr">7</td><td class="s134" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s135"></td><td class="s136"></td><td class="s137"></td><td class="s137" dir="ltr">HHLL + X</td><td class="s137"></td><td class="s138" dir="ltr">readByte &lt;&lt; 1</td><td class="s137" dir="ltr"></td><td class="s137"></td><td class="s137"></td><td class="s137" dir="ltr"></td><td class="s138" dir="ltr"></td><td class="s137" dir="ltr">readByte &gt;&gt; 7</td><td class="s137" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s138" dir="ltr">result &gt;&gt; 7</td><td class="s137" dir="ltr">readByteAddress</td><td class="s137" dir="ltr">result</td><td class="s137"></td><td class="s138"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x1E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := readByte &lt;&lt; 1; carry := readByte &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x1E ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = readByte &lt;&lt; 1; unsigned char carry = readByte &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x1E ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = readByte &lt;&lt; 1; const carry = readByte &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s137"></td><td class="s137"></td><td class="s137" dir="ltr">SR</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">carry, zero, negative</td><td class="s138"></td><td class="s139"></td><td class="s112" dir="ltr">SS 1E</td><td class="s137" dir="ltr">UNASL</td><td class="s134" dir="ltr">$SS</td><td class="s136"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s140"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s134" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s103" dir="ltr">20 LL HH</td><td class="s106" dir="ltr">JSR</td><td class="s107" dir="ltr">6</td><td class="s108" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SP - 2</td><td class="s111" dir="ltr">HHLL</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110" dir="ltr">SP - 1</td><td class="s111" dir="ltr">PC + 3</td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x20 { LL := memory[PC + 1]; newSP := SP - 2; newPC := HHLL; *SP = newSP; *PC = newPC; *PC = HHLL;memory[(SP - 1)&amp;0xFFFF] = (PC + 3)&amp;0xFF; memory[((SP - 1)+1)&amp;0xFFFF] = ((PC + 3)&gt;&gt;8&amp;0xFF; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x20 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char newSP = SP - 2; unsigned int newPC = (HHLL)&amp;0xFFFF; *SP = newSP; *PC = newPC; *PC = HHLL;memory[(SP - 1)&amp;0xFFFF] = (PC + 3)&amp;0xFF; memory[((SP - 1)+1)&amp;0xFFFF] = ((PC + 3)&gt;&gt;8&amp;0xFF; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x20 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const newSP = SP - 2; const newPC = (HHLL)&amp;0xFFFF; cpu.SP = newSP; cpu.PC = newPC; *PC = HHLL;memory[(SP - 1)&amp;0xFFFF] = (PC + 3)&amp;0xFF; memory[((SP - 1)+1)&amp;0xFFFF] = ((PC + 3)&gt;&gt;8&amp;0xFF; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ 20</td><td class="s110" dir="ltr">UNJSR</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s103" dir="ltr">21 LL</td><td class="s144" dir="ltr">AND</td><td class="s145" dir="ltr">6</td><td class="s146" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s147" dir="ltr"></td><td class="s4"></td><td class="s148" dir="ltr">LL + X</td><td class="s148" dir="ltr">zeroPageWord</td><td class="s148" dir="ltr"></td><td class="s149" dir="ltr">A &amp; readByte</td><td class="s148" dir="ltr">result</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr"></td><td class="s148"></td><td class="s148" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr">result &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x21 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := A &amp; readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x21 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x21 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = A &amp; readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s148"></td><td class="s148"></td><td class="s148" dir="ltr">SR</td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">zero, negative</td><td class="s149"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 21</td><td class="s148" dir="ltr">UNAND</td><td class="s146" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s9"></td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr">X</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">NZ....</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s146" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s103" dir="ltr">24 LL</td><td class="s150" dir="ltr">BIT</td><td class="s151" dir="ltr">3</td><td class="s152" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s153" dir="ltr"></td><td class="s4"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr">LL</td><td class="s154" dir="ltr"></td><td class="s155" dir="ltr">A &amp; readByte</td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s154"></td><td class="s154" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154" dir="ltr">readByte &gt;&gt; 6</td><td class="s155" dir="ltr">readByte &gt;&gt; 7</td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x24 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := A &amp; readByte; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := readByte &gt;&gt; 6;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x24 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = readByte &gt;&gt; 6;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x24 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = A &amp; readByte; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = readByte &gt;&gt; 6;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s154"></td><td class="s154"></td><td class="s154" dir="ltr">SR</td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr">negative, zero, overflow</td><td class="s155"></td><td class="s5"></td><td class="s112" dir="ltr">SS 24</td><td class="s154" dir="ltr">UNBIT</td><td class="s152" dir="ltr">$SS</td><td class="s4"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s9"></td><td class="s154" dir="ltr">A</td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr">$LL</td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr">NZ...V</td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s152" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s103" dir="ltr">25 LL</td><td class="s144" dir="ltr">AND</td><td class="s145" dir="ltr">3</td><td class="s146" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s147" dir="ltr"></td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">LL</td><td class="s148" dir="ltr"></td><td class="s149" dir="ltr">A &amp; readByte</td><td class="s148" dir="ltr">result</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr"></td><td class="s148"></td><td class="s148" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr">result &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x25 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := A &amp; readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x25 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x25 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = A &amp; readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s148"></td><td class="s148"></td><td class="s148" dir="ltr">SR</td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">zero, negative</td><td class="s149"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 25</td><td class="s148" dir="ltr">UNAND</td><td class="s146" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s9"></td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">$LL</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s146" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s103" dir="ltr">26 LL</td><td class="s156" dir="ltr">ROL</td><td class="s157" dir="ltr">5</td><td class="s158" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159" dir="ltr"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">LL</td><td class="s160" dir="ltr"></td><td class="s161" dir="ltr">(readByte &lt;&lt; 1) + carry</td><td class="s160" dir="ltr"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160" dir="ltr">readByte &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160" dir="ltr">readByteAddress</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x26 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := (readByte &lt;&lt; 1) + carry; carry := readByte &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x26 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = (readByte &lt;&lt; 1) + carry; unsigned char carry = readByte &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x26 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = (readByte &lt;&lt; 1) + carry; const carry = readByte &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 26</td><td class="s160" dir="ltr">UNROL</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s103" dir="ltr">28</td><td class="s113" dir="ltr">PLP</td><td class="s114" dir="ltr">4</td><td class="s115"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">SP + 1</td><td class="s117"></td><td class="s118" dir="ltr">readByte</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SP + 1</td><td class="s118"></td><td class="s117" dir="ltr">result</td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117" dir="ltr">result &gt;&gt; 2</td><td class="s117" dir="ltr">result &gt;&gt; 3</td><td class="s117" dir="ltr">0</td><td class="s117" dir="ltr">result &gt;&gt; 6</td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x28 { readByte := memory[(SP + 1)&amp;0xFFFF]; result := readByte; newSP := SP + 1; *SP = newSP; carry := result;zero := (result | -result) &gt;&gt; 7;interrupt := result &gt;&gt; 2;decimal := result &gt;&gt; 3;overflow := 0;negative := result &gt;&gt; 6;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x28 ) { unsigned char readByte = memory[(SP + 1)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newSP = SP + 1; *SP = newSP; unsigned char carry = result;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = result &gt;&gt; 2;unsigned char decimal = result &gt;&gt; 3;unsigned char overflow = 0;unsigned char negative = result &gt;&gt; 6;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x28 ) { const readByte = memory[(SP + 1)&amp;0xFFFF]; const result = readByte; const newSP = SP + 1; cpu.SP = newSP; const carry = result;const zero = (result | -result) &gt;&gt; 7;const interrupt = result &gt;&gt; 2;const decimal = result &gt;&gt; 3;const overflow = 0;const negative = result &gt;&gt; 6;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">*</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS 28</td><td class="s117" dir="ltr">UNPLP</td><td class="s115" dir="ltr">$SS</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s103" dir="ltr">29 LL</td><td class="s144" dir="ltr">AND</td><td class="s145" dir="ltr">2</td><td class="s146" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s147" dir="ltr"></td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s149" dir="ltr">A &amp; LL</td><td class="s148" dir="ltr">result</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr"></td><td class="s148"></td><td class="s148" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s148" dir="ltr"></td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr">result &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x29 { LL := memory[PC + 1]; result := A &amp; LL; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x29 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = A &amp; LL; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x29 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = A &amp; LL; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s148"></td><td class="s148"></td><td class="s148" dir="ltr">SR</td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">zero, negative</td><td class="s149"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 29</td><td class="s148" dir="ltr">UNAND</td><td class="s146" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">trash_A</td><td class="s148" dir="ltr">result</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">trash_carry</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s9"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s146" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s103" dir="ltr">2A</td><td class="s156" dir="ltr">ROL</td><td class="s157" dir="ltr">2</td><td class="s158" dir="ltr">A</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">(A &lt;&lt; 1) + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160" dir="ltr">A &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x2A { result := (A &lt;&lt; 1) + carry; newA := result; *A = newA; carry := A &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x2A ) { unsigned int result = (A &lt;&lt; 1) + carry; unsigned char newA = result; *A = newA; unsigned char carry = A &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x2A ) { const result = (A &lt;&lt; 1) + carry; const newA = result; cpu.A = newA; const carry = A &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 2A</td><td class="s160" dir="ltr">UNROL</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s103" dir="ltr">2C LL HH</td><td class="s150" dir="ltr">BIT</td><td class="s151" dir="ltr">4</td><td class="s152" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s153"></td><td class="s4"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr">HHLL</td><td class="s154"></td><td class="s155" dir="ltr">A &amp; readByte</td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s154"></td><td class="s154" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154" dir="ltr">readByte &gt;&gt; 6</td><td class="s155" dir="ltr">readByte &gt;&gt; 7</td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x2C { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := A &amp; readByte; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := readByte &gt;&gt; 6;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x2C ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = readByte &gt;&gt; 6;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x2C ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = A &amp; readByte; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = readByte &gt;&gt; 6;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s154"></td><td class="s154"></td><td class="s154" dir="ltr">SR</td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr">negative, zero, overflow</td><td class="s155"></td><td class="s5"></td><td class="s112" dir="ltr">SS 2C</td><td class="s154" dir="ltr">UNBIT</td><td class="s152" dir="ltr">$SS</td><td class="s4"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s9"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s154" dir="ltr"></td><td class="s152" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s103" dir="ltr">2D LL HH</td><td class="s144" dir="ltr">AND</td><td class="s145" dir="ltr">4</td><td class="s146" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s147"></td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">HHLL</td><td class="s148"></td><td class="s149" dir="ltr">A &amp; readByte</td><td class="s148" dir="ltr">result</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr"></td><td class="s148"></td><td class="s148" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr">result &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x2D { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := A &amp; readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x2D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x2D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = A &amp; readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s148"></td><td class="s148"></td><td class="s148" dir="ltr">SR</td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">zero, negative</td><td class="s149"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 2D</td><td class="s148" dir="ltr">UNAND</td><td class="s146" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s9"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s146" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s131" dir="ltr">2E LL HH</td><td class="s162" dir="ltr">ROL</td><td class="s163" dir="ltr">6</td><td class="s164" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s165"></td><td class="s136"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr">HHLL</td><td class="s166"></td><td class="s167" dir="ltr">(readByte &lt;&lt; 1) + carry</td><td class="s166" dir="ltr"></td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s167" dir="ltr"></td><td class="s166" dir="ltr">readByte &gt;&gt; 7</td><td class="s166" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s167" dir="ltr">result &gt;&gt; 7</td><td class="s166" dir="ltr">readByteAddress</td><td class="s166" dir="ltr">result</td><td class="s166"></td><td class="s167"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x2E { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := (readByte &lt;&lt; 1) + carry; carry := readByte &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x2E ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = (readByte &lt;&lt; 1) + carry; unsigned char carry = readByte &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x2E ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = (readByte &lt;&lt; 1) + carry; const carry = readByte &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s166"></td><td class="s166"></td><td class="s166" dir="ltr">SR</td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr">zero, negative</td><td class="s167"></td><td class="s139"></td><td class="s112" dir="ltr">SS 2E</td><td class="s166" dir="ltr">UNROL</td><td class="s164" dir="ltr">$SS</td><td class="s136"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s140"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s164" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s103" dir="ltr">30 LL</td><td class="s106" dir="ltr">BMI</td><td class="s107" dir="ltr">2**</td><td class="s108" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141" dir="ltr"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">PC + 2 + (LL &amp; (-negative))</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x30 { LL := memory[PC + 1]; newPC := PC + 2 + (LL &amp; (-negative)); *PC = newPC; *PC = PC + 2 + (LL &amp; (-negative));return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x30 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int newPC = (PC + 2 + (LL &amp; (-negative)))&amp;0xFFFF; *PC = newPC; *PC = PC + 2 + (LL &amp; (-negative));return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x30 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const newPC = (PC + 2 + (LL &amp; (-negative)))&amp;0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL &amp; (-negative));return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ 30</td><td class="s110" dir="ltr">UNBMI</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s103" dir="ltr">31 LL</td><td class="s144" dir="ltr">AND</td><td class="s145" dir="ltr">5*</td><td class="s146" dir="ltr">($LL), Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s147"></td><td class="s4"></td><td class="s148" dir="ltr">LL</td><td class="s148" dir="ltr">zeroPageWord + Y</td><td class="s148"></td><td class="s149" dir="ltr">A &amp; readByte</td><td class="s148" dir="ltr">result</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr"></td><td class="s148"></td><td class="s148" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr">result &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x31 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord + Y)&amp;0xFFFF]; result := A &amp; readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x31 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x31 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; const result = A &amp; readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s148"></td><td class="s148"></td><td class="s148" dir="ltr">SR</td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">zero, negative</td><td class="s149"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 31</td><td class="s148" dir="ltr">UNAND</td><td class="s146" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s9"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s146" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s103" dir="ltr">35 LL</td><td class="s144" dir="ltr">AND</td><td class="s145" dir="ltr">4</td><td class="s146" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s147"></td><td class="s4"></td><td class="s148" dir="ltr">LL + X</td><td class="s148" dir="ltr">zeroPageWord</td><td class="s148"></td><td class="s149" dir="ltr">A &amp; readByte</td><td class="s148" dir="ltr">result</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr"></td><td class="s148"></td><td class="s148" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr">result &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x35 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := A &amp; readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x35 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x35 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = A &amp; readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s148"></td><td class="s148"></td><td class="s148" dir="ltr">SR</td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">zero, negative</td><td class="s149"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 35</td><td class="s148" dir="ltr">UNAND</td><td class="s146" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s9"></td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr">X</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s146" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R39" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">40</div></th><td class="s103" dir="ltr">36 LL</td><td class="s156" dir="ltr">ROL</td><td class="s157" dir="ltr">6</td><td class="s158" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s160"></td><td class="s161" dir="ltr">(readByte &lt;&lt; 1) + carry</td><td class="s160" dir="ltr"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160" dir="ltr">readByte &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160" dir="ltr">readByteAddress</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x36 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := (readByte &lt;&lt; 1) + carry; carry := readByte &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x36 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = (readByte &lt;&lt; 1) + carry; unsigned char carry = readByte &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x36 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = (readByte &lt;&lt; 1) + carry; const carry = readByte &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 36</td><td class="s160" dir="ltr">UNROL</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s103" dir="ltr">38</td><td class="s106" dir="ltr">SEC</td><td class="s107" dir="ltr">2</td><td class="s108" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110" dir="ltr">0x1</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">1</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x38 { carry := 0x1;zero := (SR&gt;&gt;1)&amp;1; interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x38 ) { unsigned char carry = 0x1;unsigned char zero = (SR&gt;&gt;1)&amp;1; unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x38 ) { const carry = 0x1;const zero = (SR&gt;&gt;1)&amp;1; const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">carry</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">SS 38</td><td class="s110" dir="ltr">UNSEC</td><td class="s108" dir="ltr">$SS</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s103" dir="ltr">39 LL HH</td><td class="s144" dir="ltr">AND</td><td class="s145" dir="ltr">4*</td><td class="s146" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s147"></td><td class="s4"></td><td class="s148"></td><td class="s148" dir="ltr">HHLL + Y</td><td class="s148"></td><td class="s149" dir="ltr">A &amp; readByte</td><td class="s148" dir="ltr">result</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr"></td><td class="s148"></td><td class="s148" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr">result &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x39 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&amp;0xFFFF]; result := A &amp; readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x39 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + Y)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x39 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + Y)&amp;0xFFFF]; const result = A &amp; readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s148"></td><td class="s148"></td><td class="s148" dir="ltr">SR</td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">zero, negative</td><td class="s149"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 39</td><td class="s148" dir="ltr">UNAND</td><td class="s146" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s9"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s146" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s103" dir="ltr">3D LL HH</td><td class="s144" dir="ltr">AND</td><td class="s145" dir="ltr">4*</td><td class="s146" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s147"></td><td class="s4"></td><td class="s148"></td><td class="s148" dir="ltr">HHLL + X</td><td class="s148"></td><td class="s149" dir="ltr">A &amp; readByte</td><td class="s148" dir="ltr">result</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr"></td><td class="s148"></td><td class="s148" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149" dir="ltr">result &gt;&gt; 7</td><td class="s148"></td><td class="s148"></td><td class="s148"></td><td class="s149"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x3D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := A &amp; readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x3D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = A &amp; readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x3D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = A &amp; readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s148"></td><td class="s148"></td><td class="s148" dir="ltr">SR</td><td class="s148" dir="ltr">A</td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr">zero, negative</td><td class="s149"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 3D</td><td class="s148" dir="ltr">UNAND</td><td class="s146" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s9"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s148" dir="ltr"></td><td class="s146" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R43" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">44</div></th><td class="s131" dir="ltr">3E LL HH</td><td class="s162" dir="ltr">ROL</td><td class="s163" dir="ltr">7</td><td class="s164" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s165"></td><td class="s136"></td><td class="s166"></td><td class="s166" dir="ltr">HHLL + X</td><td class="s166"></td><td class="s167" dir="ltr">(readByte &lt;&lt; 1) + carry</td><td class="s166" dir="ltr"></td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s167" dir="ltr"></td><td class="s166" dir="ltr">readByte &gt;&gt; 7</td><td class="s166" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s167" dir="ltr">result &gt;&gt; 7</td><td class="s166" dir="ltr">readByteAddress</td><td class="s166" dir="ltr">result</td><td class="s166"></td><td class="s167"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x3E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := (readByte &lt;&lt; 1) + carry; carry := readByte &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x3E ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = (readByte &lt;&lt; 1) + carry; unsigned char carry = readByte &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x3E ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = (readByte &lt;&lt; 1) + carry; const carry = readByte &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s166"></td><td class="s166"></td><td class="s166" dir="ltr">SR</td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr">zero, negative</td><td class="s167"></td><td class="s139"></td><td class="s112" dir="ltr">SS 3E</td><td class="s166" dir="ltr">UNROL</td><td class="s164" dir="ltr">$SS</td><td class="s136"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s140"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s164" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s103" dir="ltr">40</td><td class="s106" dir="ltr">RTI</td><td class="s107" dir="ltr">6</td><td class="s108"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141" dir="ltr"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">SP + 1</td><td class="s110" dir="ltr">SP + 3</td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SP + 3</td><td class="s111" dir="ltr">readWord</td><td class="s110" dir="ltr">result</td><td class="s110" dir="ltr">result &gt;&gt; 1</td><td class="s110" dir="ltr">result &gt;&gt; 2</td><td class="s110" dir="ltr">result &gt;&gt; 3</td><td class="s110" dir="ltr">0</td><td class="s110" dir="ltr">result &gt;&gt; 6</td><td class="s111" dir="ltr">result &gt;&gt; 7</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x40 { readByte := memory[(SP + 1)&amp;0xFFFF]; readWord := memory[(SP + 3)&amp;0xFFFF] + (memory[((SP + 3)+1)&amp;0xFFFF]&lt;&lt;8); newSP := SP + 3; newPC := readWord; *SP = newSP; *PC = newPC; carry := result;zero := result &gt;&gt; 1;interrupt := result &gt;&gt; 2;decimal := result &gt;&gt; 3;overflow := 0;negative := result &gt;&gt; 6;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = readWord;return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x40 ) { unsigned char readByte = memory[(SP + 1)&amp;0xFFFF]; unsigned int readWord := memory[(SP + 3)&amp;0xFFFF] + (memory[((SP + 3)+1)&amp;0xFFFF]&lt;&lt;8); unsigned char newSP = SP + 3; unsigned int newPC = (readWord)&amp;0xFFFF; *SP = newSP; *PC = newPC; unsigned char carry = result;unsigned char zero = result &gt;&gt; 1;unsigned char interrupt = result &gt;&gt; 2;unsigned char decimal = result &gt;&gt; 3;unsigned char overflow = 0;unsigned char negative = result &gt;&gt; 6;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = readWord;return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x40 ) { const readByte = memory[(SP + 1)&amp;0xFFFF]; const readWord = memory[(SP + 3)&amp;0xFFFF] + (memory[((SP + 3)+1)&amp;0xFFFF]&lt;&lt;8); const newSP = SP + 3; const newPC = (readWord)&amp;0xFFFF; cpu.SP = newSP; cpu.PC = newPC; const carry = result;const zero = result &gt;&gt; 1;const interrupt = result &gt;&gt; 2;const decimal = result &gt;&gt; 3;const overflow = 0;const negative = result &gt;&gt; 6;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = readWord;return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">SS PP QQ 40</td><td class="s110" dir="ltr">UNRTI</td><td class="s108" dir="ltr">$SS, $QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R45" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">46</div></th><td class="s103" dir="ltr">41 LL</td><td class="s168" dir="ltr">EOR</td><td class="s169" dir="ltr">6</td><td class="s170" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171" dir="ltr"></td><td class="s4"></td><td class="s172" dir="ltr">LL + X</td><td class="s172" dir="ltr">zeroPageWord</td><td class="s172" dir="ltr"></td><td class="s173" dir="ltr">A ^ readByte</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172"></td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x41 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x41 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x41 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">zero, negative</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS 41</td><td class="s172" dir="ltr">UNEOR</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s103" dir="ltr">45 LL</td><td class="s168" dir="ltr">EOR</td><td class="s169" dir="ltr">3</td><td class="s170" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">LL</td><td class="s172"></td><td class="s173" dir="ltr">A ^ readByte</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172"></td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x45 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x45 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x45 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">zero, negative</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS 45</td><td class="s172" dir="ltr">UNEOR</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s103" dir="ltr">46 LL</td><td class="s174" dir="ltr">LSR</td><td class="s175" dir="ltr">5</td><td class="s176" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">LL</td><td class="s178"></td><td class="s179" dir="ltr">readByte &gt;&gt; 1</td><td class="s178" dir="ltr">result</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">readByte</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">0x0</td><td class="s178" dir="ltr">readByteAddress</td><td class="s178" dir="ltr">result</td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x46 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := readByte &gt;&gt; 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x46 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = readByte &gt;&gt; 1; unsigned char newA = result; *A = newA; unsigned char carry = readByte;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x46 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = readByte &gt;&gt; 1; const newA = result; cpu.A = newA; const carry = readByte;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS 46</td><td class="s178" dir="ltr">UNLSR</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s103" dir="ltr">48</td><td class="s180" dir="ltr">PHA</td><td class="s120" dir="ltr">3</td><td class="s121" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122"></td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SP - 1</td><td class="s124"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s123" dir="ltr">SP</td><td class="s123" dir="ltr">A</td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x48 { newSP := SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&amp;0xFFFF] = A; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x48 ) { unsigned char newSP = SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x48 ) { const newSP = SP - 1; cpu.SP = newSP; cpu.PC = PC + 1; memory[(SP)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr">writeByteAddress</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">BB 48</td><td class="s123">UNPHA</td><td class="s121" dir="ltr">$BB</td><td class="s4"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s121"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s103" dir="ltr">49 LL</td><td class="s168" dir="ltr">EOR</td><td class="s169" dir="ltr">2</td><td class="s170" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171" dir="ltr"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s173" dir="ltr">A ^ LL</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172"></td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x49 { LL := memory[PC + 1]; result := A ^ LL; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x49 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = A ^ LL; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x49 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = A ^ LL; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">zero, negative</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS 49</td><td class="s172" dir="ltr">UNEOR</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R50" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">51</div></th><td class="s103" dir="ltr">4A</td><td class="s174" dir="ltr">LSR</td><td class="s175" dir="ltr">2</td><td class="s176" dir="ltr">A</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">A &gt;&gt; 1</td><td class="s178" dir="ltr">result</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">A</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">0x0</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x4A { result := A &gt;&gt; 1; newA := result; *A = newA; carry := A;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x4A ) { unsigned int result = A &gt;&gt; 1; unsigned char newA = result; *A = newA; unsigned char carry = A;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x4A ) { const result = A &gt;&gt; 1; const newA = result; cpu.A = newA; const carry = A;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS 4A</td><td class="s178" dir="ltr">UNLSR</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s103" dir="ltr">4C</td><td class="s106" dir="ltr">JMP</td><td class="s107" dir="ltr">5</td><td class="s108" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">HHLL</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x4C { newPC := HHLL; *PC = newPC; *PC = HHLL;return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x4C ) { unsigned int newPC = (HHLL)&amp;0xFFFF; *PC = newPC; *PC = HHLL;return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x4C ) { const newPC = (HHLL)&amp;0xFFFF; cpu.PC = newPC; *PC = HHLL;return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ 4C</td><td class="s110" dir="ltr">UNJMP</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R52" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">53</div></th><td class="s103" dir="ltr">4D LL HH</td><td class="s168" dir="ltr">EOR</td><td class="s169" dir="ltr">4</td><td class="s170" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">HHLL</td><td class="s172"></td><td class="s173" dir="ltr">A ^ readByte</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr"></td><td class="s172"></td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x4D { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x4D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x4D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">zero, negative</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS 4D</td><td class="s172" dir="ltr">UNEOR</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R53" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">54</div></th><td class="s131" dir="ltr">4E LL HH</td><td class="s181" dir="ltr">LSR</td><td class="s182" dir="ltr">6</td><td class="s183" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s184"></td><td class="s136"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr">HHLL</td><td class="s185"></td><td class="s186" dir="ltr">readByte &gt;&gt; 1</td><td class="s185" dir="ltr">result</td><td class="s185"></td><td class="s185"></td><td class="s185"></td><td class="s186"></td><td class="s185" dir="ltr">readByte</td><td class="s185" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s185"></td><td class="s185"></td><td class="s185"></td><td class="s185"></td><td class="s186" dir="ltr">0x0</td><td class="s185" dir="ltr">readByteAddress</td><td class="s185" dir="ltr">result</td><td class="s185"></td><td class="s186"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x4E { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := readByte &gt;&gt; 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x4E ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = readByte &gt;&gt; 1; unsigned char newA = result; *A = newA; unsigned char carry = readByte;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x4E ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = readByte &gt;&gt; 1; const newA = result; cpu.A = newA; const carry = readByte;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s185"></td><td class="s185"></td><td class="s185" dir="ltr">SR</td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr">carry, zero, negative</td><td class="s186"></td><td class="s139"></td><td class="s112" dir="ltr">SS 4E</td><td class="s185" dir="ltr">UNLSR</td><td class="s183" dir="ltr">$SS</td><td class="s136"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s140"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s183" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R54" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">55</div></th><td class="s187" dir="ltr">50 LL</td><td class="s106" dir="ltr">BVC</td><td class="s107" dir="ltr">2**</td><td class="s108" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s188" dir="ltr">Branch if overflow clear</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">PC + 2 + (LL &amp; (overflow-1))</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x50 { LL := memory[PC + 1]; newPC := PC + 2 + (LL &amp; (overflow-1)); *PC = newPC; *PC = PC + 2 + (LL &amp; (overflow-1));return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x50 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int newPC = (PC + 2 + (LL &amp; (overflow-1)))&amp;0xFFFF; *PC = newPC; *PC = PC + 2 + (LL &amp; (overflow-1));return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x50 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const newPC = (PC + 2 + (LL &amp; (overflow-1)))&amp;0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL &amp; (overflow-1));return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ 50</td><td class="s110" dir="ltr">UNBVC</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s187" dir="ltr">51 LL</td><td class="s168" dir="ltr">EOR</td><td class="s169" dir="ltr">5*</td><td class="s170" dir="ltr">($LL), Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr">LL</td><td class="s172" dir="ltr">zeroPageWord + Y</td><td class="s172"></td><td class="s173" dir="ltr">A ^ readByte</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172"></td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x51 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord + Y)&amp;0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x51 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x51 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">zero, negative</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS 51</td><td class="s172" dir="ltr">UNEOR</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s187" dir="ltr">55 LL</td><td class="s168" dir="ltr">EOR</td><td class="s169" dir="ltr">4</td><td class="s170" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171" dir="ltr"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s172" dir="ltr"></td><td class="s173" dir="ltr">A ^ readByte</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172"></td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x55 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x55 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x55 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">zero, negative</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS 55</td><td class="s172" dir="ltr">UNEOR</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s187" dir="ltr">56 LL</td><td class="s174" dir="ltr">LSR</td><td class="s175" dir="ltr">6</td><td class="s176" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s178"></td><td class="s179" dir="ltr">readByte &gt;&gt; 1</td><td class="s178" dir="ltr">result</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">readByte</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">0x0</td><td class="s178" dir="ltr">readByteAddress</td><td class="s178" dir="ltr">result</td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x56 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := readByte &gt;&gt; 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x56 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = readByte &gt;&gt; 1; unsigned char newA = result; *A = newA; unsigned char carry = readByte;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x56 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = readByte &gt;&gt; 1; const newA = result; cpu.A = newA; const carry = readByte;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS 56</td><td class="s178" dir="ltr">UNLSR</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s187" dir="ltr">58</td><td class="s106" dir="ltr">CLI</td><td class="s107" dir="ltr">2</td><td class="s108"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">0x0</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x58 { carry := SR&amp;1; zero := (SR&gt;&gt;1)&amp;1; interrupt := 0x0;decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x58 ) { unsigned char carry = SR&amp;1; unsigned char zero = (SR&gt;&gt;1)&amp;1; unsigned char interrupt = 0x0;unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x58 ) { const carry = SR&amp;1; const zero = (SR&gt;&gt;1)&amp;1; const interrupt = 0x0;const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">interrupt</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">SS 58</td><td class="s110" dir="ltr">UNCLI</td><td class="s108" dir="ltr">$SS</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R59" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">60</div></th><td class="s187" dir="ltr">59 LL HH</td><td class="s168" dir="ltr">EOR</td><td class="s169" dir="ltr">4*</td><td class="s170" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">HHLL + Y</td><td class="s172"></td><td class="s173" dir="ltr">A ^ readByte</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172"></td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x59 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&amp;0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x59 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + Y)&amp;0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x59 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + Y)&amp;0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">zero, negative</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS 59</td><td class="s172" dir="ltr">UNEOR</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R60" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">61</div></th><td class="s187" dir="ltr">5D LL HH</td><td class="s168" dir="ltr">EOR</td><td class="s169" dir="ltr">4*</td><td class="s170" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">HHLL + X</td><td class="s172"></td><td class="s173" dir="ltr">A ^ readByte</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr"></td><td class="s172"></td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x5D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x5D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x5D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">zero, negative</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS 5D</td><td class="s172" dir="ltr">UNEOR</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s143" dir="ltr">5E</td><td class="s181" dir="ltr">LSR</td><td class="s182" dir="ltr">7</td><td class="s183" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s184"></td><td class="s136"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr">HHLL + X</td><td class="s185"></td><td class="s186" dir="ltr">readByte &gt;&gt; 1</td><td class="s185" dir="ltr">result</td><td class="s185"></td><td class="s185"></td><td class="s185"></td><td class="s186"></td><td class="s185" dir="ltr">readByte</td><td class="s185" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s185"></td><td class="s185"></td><td class="s185"></td><td class="s185"></td><td class="s186" dir="ltr">0x0</td><td class="s185" dir="ltr">readByteAddress</td><td class="s185" dir="ltr">result</td><td class="s185"></td><td class="s186"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x5E { readByte := memory[(HHLL + X)&amp;0xFFFF]; result := readByte &gt;&gt; 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x5E ) { unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = readByte &gt;&gt; 1; unsigned char newA = result; *A = newA; unsigned char carry = readByte;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x5E ) { const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = readByte &gt;&gt; 1; const newA = result; cpu.A = newA; const carry = readByte;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s185"></td><td class="s185"></td><td class="s185" dir="ltr">SR</td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr">carry, zero, negative</td><td class="s186"></td><td class="s139"></td><td class="s112" dir="ltr">SS 5E</td><td class="s185" dir="ltr">UNLSR</td><td class="s183" dir="ltr">$SS</td><td class="s136"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s140"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s185" dir="ltr"></td><td class="s183" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s103" dir="ltr">60</td><td class="s106" dir="ltr">RTS</td><td class="s107" dir="ltr">6</td><td class="s108"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141" dir="ltr"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110" dir="ltr">SP + 1</td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SP + 2</td><td class="s111" dir="ltr">readWord</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x60 { readWord := memory[(SP + 1)&amp;0xFFFF] + (memory[((SP + 1)+1)&amp;0xFFFF]&lt;&lt;8); newSP := SP + 2; newPC := readWord; *SP = newSP; *PC = newPC; *PC = readWord;return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x60 ) { unsigned int readWord := memory[(SP + 1)&amp;0xFFFF] + (memory[((SP + 1)+1)&amp;0xFFFF]&lt;&lt;8); unsigned char newSP = SP + 2; unsigned int newPC = (readWord)&amp;0xFFFF; *SP = newSP; *PC = newPC; *PC = readWord;return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x60 ) { const readWord = memory[(SP + 1)&amp;0xFFFF] + (memory[((SP + 1)+1)&amp;0xFFFF]&lt;&lt;8); const newSP = SP + 2; const newPC = (readWord)&amp;0xFFFF; cpu.SP = newSP; cpu.PC = newPC; *PC = readWord;return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr">PC</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ 60</td><td class="s110" dir="ltr">UNRTS</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s103" dir="ltr">61 LL</td><td class="s156" dir="ltr">ADC</td><td class="s157" dir="ltr">6</td><td class="s158" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159" dir="ltr"></td><td class="s4"></td><td class="s160" dir="ltr">LL + X</td><td class="s160" dir="ltr">zeroPageWord</td><td class="s160" dir="ltr"></td><td class="s161" dir="ltr">A + readByte + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr"></td><td class="s160" dir="ltr">(A - result) &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7</td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x61 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x61 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x61 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero, overflow</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 61</td><td class="s160" dir="ltr">UNADC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr">X</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">$LL</td><td class="s160" dir="ltr">..C...</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">NZC..V</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s103" dir="ltr">65 LL</td><td class="s156" dir="ltr">ADC</td><td class="s157" dir="ltr">3</td><td class="s158" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">LL</td><td class="s160"></td><td class="s161" dir="ltr">A + readByte + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr"></td><td class="s160" dir="ltr">(A - result) &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7</td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x65 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x65 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x65 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero, overflow</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 65</td><td class="s160" dir="ltr">UNADC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">$LL</td><td class="s160" dir="ltr">..C...</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">NZC..V</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s103" dir="ltr">66 LL</td><td class="s180" dir="ltr">ROR</td><td class="s120" dir="ltr">5</td><td class="s121" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122"></td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">LL</td><td class="s123"></td><td class="s124" dir="ltr">(readByte &gt;&gt; 1) + (carry &lt;&lt; 7)</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s123" dir="ltr">readByte</td><td class="s123" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">result &gt;&gt; 7</td><td class="s123" dir="ltr">readByteAddress</td><td class="s123" dir="ltr">result</td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x66 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); carry := readByte;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x66 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); unsigned char carry = readByte;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x66 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); const carry = readByte;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SR</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">zero, negative</td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">SS 66</td><td class="s123" dir="ltr">UNROR</td><td class="s121" dir="ltr">$SS</td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s121" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R66" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">67</div></th><td class="s103" dir="ltr">68</td><td class="s125" dir="ltr">PLA</td><td class="s126" dir="ltr">4</td><td class="s127"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s128"></td><td class="s4"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr">SP + 1</td><td class="s129"></td><td class="s130" dir="ltr">readByte</td><td class="s129" dir="ltr">result</td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s130"></td><td class="s129"></td><td class="s129" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s130" dir="ltr">result &gt;&gt; 7</td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s130"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x68 { readByte := memory[(SP + 1)&amp;0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x68 ) { unsigned char readByte = memory[(SP + 1)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x68 ) { const readByte = memory[(SP + 1)&amp;0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s129"></td><td class="s129"></td><td class="s129" dir="ltr">SR</td><td class="s129" dir="ltr">A</td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr">A, zero, negative</td><td class="s130"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 68</td><td class="s129" dir="ltr">UNPLA</td><td class="s127" dir="ltr">$SS</td><td class="s4"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s9"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s127" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s103" dir="ltr">69 LL</td><td class="s156" dir="ltr">ADC</td><td class="s157" dir="ltr">2</td><td class="s158" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159" dir="ltr"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s161" dir="ltr">A + LL + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr"></td><td class="s160" dir="ltr">(A - result) &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7</td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x69 { LL := memory[PC + 1]; result := A + LL + carry; newA := result; *A = newA; carry := (A - result) &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x69 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = A + LL + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x69 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = A + LL + carry; const newA = result; cpu.A = newA; const carry = (A - result) &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero, overflow</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 69</td><td class="s160" dir="ltr">UNADC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">..C...</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">NZC..V</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s103" dir="ltr">6A</td><td class="s180" dir="ltr">ROR</td><td class="s120" dir="ltr">2</td><td class="s121" dir="ltr">A</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122"></td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">(A &gt;&gt; 1) + (carry &lt;&lt; 7)</td><td class="s123" dir="ltr">result</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s123" dir="ltr">A</td><td class="s123" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">result &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x6A { result := (A &gt;&gt; 1) + (carry &lt;&lt; 7); newA := result; *A = newA; carry := A;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x6A ) { unsigned int result = (A &gt;&gt; 1) + (carry &lt;&lt; 7); unsigned char newA = result; *A = newA; unsigned char carry = A;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x6A ) { const result = (A &gt;&gt; 1) + (carry &lt;&lt; 7); const newA = result; cpu.A = newA; const carry = A;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SR</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">zero, negative</td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">SS 6A</td><td class="s123" dir="ltr">UNROR</td><td class="s121" dir="ltr">$SS</td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s121" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s103" dir="ltr">6C</td><td class="s106" dir="ltr">JMP</td><td class="s107" dir="ltr">3</td><td class="s108" dir="ltr">($HHLL)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141" dir="ltr"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">HHLL</td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">readWord</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x6C { readWord := memory[(HHLL)&amp;0xFFFF] + (memory[((HHLL)+1)&amp;0xFFFF]&lt;&lt;8); newPC := readWord; *PC = newPC; *PC = readWord;return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x6C ) { unsigned int readWord := memory[(HHLL)&amp;0xFFFF] + (memory[((HHLL)+1)&amp;0xFFFF]&lt;&lt;8); unsigned int newPC = (readWord)&amp;0xFFFF; *PC = newPC; *PC = readWord;return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x6C ) { const readWord = memory[(HHLL)&amp;0xFFFF] + (memory[((HHLL)+1)&amp;0xFFFF]&lt;&lt;8); const newPC = (readWord)&amp;0xFFFF; cpu.PC = newPC; *PC = readWord;return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr">PC</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ 6C</td><td class="s110" dir="ltr">UNJMP</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s103" dir="ltr">6D LL HH</td><td class="s156" dir="ltr">ADC</td><td class="s157" dir="ltr">4</td><td class="s158" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">HHLL</td><td class="s160"></td><td class="s161" dir="ltr">A + readByte + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr"></td><td class="s160" dir="ltr">(A - result) &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7</td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x6D { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x6D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x6D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero, overflow</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 6D</td><td class="s160" dir="ltr">UNADC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">$HHLL</td><td class="s160" dir="ltr">..C...</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">NZC..V</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R71" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">72</div></th><td class="s131" dir="ltr">6E LL HH</td><td class="s189" dir="ltr">ROR</td><td class="s133" dir="ltr">6</td><td class="s134" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s135"></td><td class="s136"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">HHLL</td><td class="s137"></td><td class="s138" dir="ltr">(readByte &gt;&gt; 1) + (carry &lt;&lt; 7)</td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s138" dir="ltr"></td><td class="s137" dir="ltr">readByte</td><td class="s137" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s138" dir="ltr">result &gt;&gt; 7</td><td class="s137" dir="ltr">readByteAddress</td><td class="s137" dir="ltr">result</td><td class="s137"></td><td class="s138"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x6E { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); carry := readByte;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x6E ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); unsigned char carry = readByte;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x6E ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); const carry = readByte;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s137"></td><td class="s137"></td><td class="s137" dir="ltr">SR</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">zero, negative</td><td class="s138"></td><td class="s139"></td><td class="s112" dir="ltr">SS 6E</td><td class="s137" dir="ltr">UNROR</td><td class="s134" dir="ltr">$SS</td><td class="s136"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s140"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s134" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s103" dir="ltr">70 LL</td><td class="s106" dir="ltr">BVS</td><td class="s107" dir="ltr">2**</td><td class="s108" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">PC + 2 + (LL &amp; (-overflow))</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x70 { LL := memory[PC + 1]; newPC := PC + 2 + (LL &amp; (-overflow)); *PC = newPC; *PC = PC + 2 + (LL &amp; (-overflow));return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x70 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int newPC = (PC + 2 + (LL &amp; (-overflow)))&amp;0xFFFF; *PC = newPC; *PC = PC + 2 + (LL &amp; (-overflow));return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x70 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const newPC = (PC + 2 + (LL &amp; (-overflow)))&amp;0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL &amp; (-overflow));return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ 70</td><td class="s110" dir="ltr">UNBVS</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R73" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">74</div></th><td class="s103" dir="ltr">71 LL</td><td class="s156" dir="ltr">ADC</td><td class="s157" dir="ltr">5*</td><td class="s158" dir="ltr">($LL),Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr">LL</td><td class="s160" dir="ltr">zeroPageWord + Y</td><td class="s160"></td><td class="s161" dir="ltr">A + readByte + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr"></td><td class="s160" dir="ltr">(A - result) &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7</td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x71 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord + Y)&amp;0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x71 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x71 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero, overflow</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 71</td><td class="s160" dir="ltr">UNADC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr">Y</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">..C...</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">NZC..V</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R74" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">75</div></th><td class="s103" dir="ltr">75 LL</td><td class="s156" dir="ltr">ADC</td><td class="s157" dir="ltr">4</td><td class="s158" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160"></td><td class="s160" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s160"></td><td class="s161" dir="ltr">A + readByte + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr"></td><td class="s160" dir="ltr">(A - result) &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7</td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x75 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x75 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x75 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero, overflow</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 75</td><td class="s160" dir="ltr">UNADC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr">X</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">..C...</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">NZC..V</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R75" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">76</div></th><td class="s103" dir="ltr">76 LL</td><td class="s180" dir="ltr">ROR</td><td class="s120" dir="ltr">6</td><td class="s121" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122"></td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s123"></td><td class="s124" dir="ltr">(readByte &gt;&gt; 1) + (carry &lt;&lt; 7)</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s123" dir="ltr">readByte</td><td class="s123" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">result &gt;&gt; 7</td><td class="s123" dir="ltr">readByteAddress</td><td class="s123" dir="ltr">result</td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x76 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); carry := readByte;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x76 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); unsigned char carry = readByte;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x76 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); const carry = readByte;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SR</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">zero, negative</td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">SS 76</td><td class="s123" dir="ltr">UNROR</td><td class="s121" dir="ltr">$SS</td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s121" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R76" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">77</div></th><td class="s103" dir="ltr">78</td><td class="s106" dir="ltr">SEI</td><td class="s107" dir="ltr">2</td><td class="s108" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">0x1</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x78 { carry := SR&amp;1; zero := (SR&gt;&gt;1)&amp;1; interrupt := 0x1;decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x78 ) { unsigned char carry = SR&amp;1; unsigned char zero = (SR&gt;&gt;1)&amp;1; unsigned char interrupt = 0x1;unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x78 ) { const carry = SR&amp;1; const zero = (SR&gt;&gt;1)&amp;1; const interrupt = 0x1;const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">interrupt</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">SS 78</td><td class="s110" dir="ltr">UNSEI</td><td class="s108" dir="ltr">$SS</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R77" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">78</div></th><td class="s103" dir="ltr">79 LL HH</td><td class="s156" dir="ltr">ADC</td><td class="s157" dir="ltr">4*</td><td class="s158" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">HHLL + Y</td><td class="s160"></td><td class="s161" dir="ltr">A + readByte + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr"></td><td class="s160" dir="ltr">(A - result) &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7</td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x79 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&amp;0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x79 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + Y)&amp;0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x79 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + Y)&amp;0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero, overflow</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 79</td><td class="s160" dir="ltr">UNADC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr">Y</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">..C...</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">NZC..V</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s103" dir="ltr">7D LL HH</td><td class="s156" dir="ltr">ADC</td><td class="s157" dir="ltr">4*</td><td class="s158" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">HHLL + X</td><td class="s160"></td><td class="s161" dir="ltr">A + readByte + carry</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr"></td><td class="s160" dir="ltr">(A - result) &gt;&gt; 7</td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7</td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x7D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) &gt;&gt; 7;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x7D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) &gt;&gt; 7;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x7D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) &gt;&gt; 7;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ((A ^ result) &amp; (readByte ^ result)) &gt;&gt; 7;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero, overflow</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS 7D</td><td class="s160" dir="ltr">UNADC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr">X</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">..C...</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">NZC..V</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s131" dir="ltr">7E LL HH</td><td class="s189" dir="ltr">ROR</td><td class="s133" dir="ltr">7</td><td class="s134" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s135"></td><td class="s136"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">HHLL + X</td><td class="s137"></td><td class="s138" dir="ltr">(readByte &gt;&gt; 1) + (carry &lt;&lt; 7)</td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s138" dir="ltr"></td><td class="s137" dir="ltr">readByte</td><td class="s137" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s137"></td><td class="s138" dir="ltr">result &gt;&gt; 7</td><td class="s137" dir="ltr">readByteAddress</td><td class="s137" dir="ltr">result</td><td class="s137"></td><td class="s138"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x7E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); carry := readByte;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x7E ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); unsigned char carry = readByte;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x7E ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = (readByte &gt;&gt; 1) + (carry &lt;&lt; 7); const carry = readByte;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s137"></td><td class="s137"></td><td class="s137" dir="ltr">SR</td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr">zero, negative</td><td class="s138"></td><td class="s139"></td><td class="s112" dir="ltr">SS 7E</td><td class="s137" dir="ltr">UNROR</td><td class="s134" dir="ltr">$SS</td><td class="s136"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s140"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s137" dir="ltr"></td><td class="s134" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R80" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">81</div></th><td class="s103" dir="ltr">81 LL</td><td class="s190" dir="ltr">STA</td><td class="s191" dir="ltr">6</td><td class="s192" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s193" dir="ltr"></td><td class="s4"></td><td class="s194" dir="ltr">LL + X</td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194" dir="ltr">zeroPageWord</td><td class="s194" dir="ltr">A</td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x81 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); *PC = PC + 2; memory[(zeroPageWord)&amp;0xFFFF] = A; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x81 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); *PC = PC + 2; memory[(zeroPageWord)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x81 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); cpu.PC = PC + 2; memory[(zeroPageWord)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s194" dir="ltr">writeByteAddress</td><td class="s194"></td><td class="s194"></td><td class="s194" dir="ltr">A</td><td class="s194"></td><td class="s194" dir="ltr">A</td><td class="s195"></td><td class="s5"></td><td class="s112" dir="ltr">BB RR 81</td><td class="s194">UNSTA</td><td class="s192" dir="ltr">$BB, $RR</td><td class="s4"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s9"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s192"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R81" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">82</div></th><td class="s103" dir="ltr">84 LL</td><td class="s156" dir="ltr">STY</td><td class="s157" dir="ltr">3</td><td class="s158" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160" dir="ltr">LL</td><td class="s160" dir="ltr">Y</td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x84 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&amp;0xFFFF] = Y; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x84 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; *PC = PC + 2; memory[(LL)&amp;0xFFFF] = Y; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x84 ) { const LL = memory[(PC+1)&amp;0xFFFF]; cpu.PC = PC + 2; memory[(LL)&amp;0xFFFF] = Y; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">writeByteAddress</td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">A</td><td class="s160"></td><td class="s160" dir="ltr">A</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">BB RR 84</td><td class="s160">UNSTY</td><td class="s158" dir="ltr">$BB, $RR</td><td class="s4"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s158"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s103" dir="ltr">85 LL</td><td class="s190" dir="ltr">STA</td><td class="s191" dir="ltr">3</td><td class="s192" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s193"></td><td class="s4"></td><td class="s194" dir="ltr"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194" dir="ltr">LL</td><td class="s194" dir="ltr">A</td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x85 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&amp;0xFFFF] = A; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x85 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; *PC = PC + 2; memory[(LL)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x85 ) { const LL = memory[(PC+1)&amp;0xFFFF]; cpu.PC = PC + 2; memory[(LL)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s194" dir="ltr">writeByteAddress</td><td class="s194"></td><td class="s194"></td><td class="s194" dir="ltr">A</td><td class="s194"></td><td class="s194" dir="ltr">A</td><td class="s195"></td><td class="s5"></td><td class="s112" dir="ltr">BB RR 85</td><td class="s194">UNSTA</td><td class="s192" dir="ltr">$BB, $RR</td><td class="s4"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s9"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s192"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s103" dir="ltr">86 LL</td><td class="s150" dir="ltr">STX</td><td class="s151" dir="ltr">3</td><td class="s152" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s153"></td><td class="s4"></td><td class="s154" dir="ltr"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s154" dir="ltr">LL</td><td class="s154" dir="ltr">X</td><td class="s154"></td><td class="s155"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x86 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&amp;0xFFFF] = X; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x86 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; *PC = PC + 2; memory[(LL)&amp;0xFFFF] = X; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x86 ) { const LL = memory[(PC+1)&amp;0xFFFF]; cpu.PC = PC + 2; memory[(LL)&amp;0xFFFF] = X; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s154" dir="ltr">writeByteAddress</td><td class="s154"></td><td class="s154"></td><td class="s154" dir="ltr">A</td><td class="s154"></td><td class="s154" dir="ltr">A</td><td class="s155"></td><td class="s5"></td><td class="s112" dir="ltr">BB RR 86</td><td class="s154">UNSTX</td><td class="s152" dir="ltr">$BB, $RR</td><td class="s4"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s9"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s152"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s103" dir="ltr">88</td><td class="s113" dir="ltr">DEY</td><td class="s114" dir="ltr">2</td><td class="s115" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s118" dir="ltr">Y - 1</td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x88 { result := Y - 1; newY := result; *Y = newY; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x88 ) { unsigned int result = Y - 1; unsigned char newY = result; *Y = newY; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x88 ) { const result = Y - 1; const newY = result; cpu.Y = newY; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">negative, zero</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS 88</td><td class="s117" dir="ltr">UNDEY</td><td class="s115" dir="ltr">$SS</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s103" dir="ltr">8A</td><td class="s119" dir="ltr">TXA</td><td class="s196" dir="ltr">2</td><td class="s197" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s198"></td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199"></td><td class="s199"></td><td class="s200" dir="ltr">X</td><td class="s199" dir="ltr">result</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s199"></td><td class="s199" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200" dir="ltr">result &gt;&gt; 7</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x8A { result := X; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x8A ) { unsigned int result = X; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x8A ) { const result = X; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s199"></td><td class="s199"></td><td class="s199" dir="ltr">SR</td><td class="s199" dir="ltr">A</td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr">zero, negative</td><td class="s200"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 8A</td><td class="s199" dir="ltr">UNTXA</td><td class="s197" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s9"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s197" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s103" dir="ltr">8C LL HH</td><td class="s156" dir="ltr">STY</td><td class="s157" dir="ltr">4</td><td class="s158" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160" dir="ltr">HHLL</td><td class="s160" dir="ltr">Y</td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x8C { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = Y; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x8C ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); *PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = Y; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x8C ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); cpu.PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = Y; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">writeByteAddress</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">BB 8C</td><td class="s160">UNSTY</td><td class="s158" dir="ltr">$BB</td><td class="s4"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s158"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s103" dir="ltr">8D LL HH</td><td class="s190" dir="ltr">STA</td><td class="s191" dir="ltr">4</td><td class="s192" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s193"></td><td class="s4"></td><td class="s194" dir="ltr"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194" dir="ltr">HHLL</td><td class="s194" dir="ltr">A</td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x8D { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = A; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x8D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); *PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x8D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); cpu.PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s194" dir="ltr">writeByteAddress</td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s112" dir="ltr">BB 8D</td><td class="s194">UNSTA</td><td class="s192" dir="ltr">$BB</td><td class="s4"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s9"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s192"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R88" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">89</div></th><td class="s131" dir="ltr">8E LL HH</td><td class="s201" dir="ltr">STX</td><td class="s202" dir="ltr">4</td><td class="s203" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s204"></td><td class="s136"></td><td class="s205" dir="ltr"></td><td class="s205"></td><td class="s205"></td><td class="s206"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s206" dir="ltr"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s206"></td><td class="s205" dir="ltr">HHLL</td><td class="s205" dir="ltr">X</td><td class="s205"></td><td class="s206"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x8E { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = X; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x8E ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); *PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = X; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x8E ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); cpu.PC = PC + 3; memory[(HHLL)&amp;0xFFFF] = X; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s205" dir="ltr">writeByteAddress</td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s206"></td><td class="s139"></td><td class="s112" dir="ltr">BB 8E</td><td class="s205">UNSTX</td><td class="s203" dir="ltr">$BB</td><td class="s136"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s140"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s205"></td><td class="s203"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R89" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">90</div></th><td class="s103" dir="ltr">90 LL</td><td class="s106" dir="ltr">BCC</td><td class="s107" dir="ltr">2**</td><td class="s108" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s207 softmerge" dir="ltr"><div class="softmerge-inner" style="width:258px;left:-1px">Branch if carry flag is clear to the relative address specified by LL. The branch destination is relative to the start byte of the next instruction.</div></td><td class="s3"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">PC + 2 + (LL &amp; (carry-1))</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x90 { LL := memory[PC + 1]; newPC := PC + 2 + (LL &amp; (carry-1)); *PC = newPC; *PC = PC + 2 + (LL &amp; (carry-1));return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x90 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int newPC = (PC + 2 + (LL &amp; (carry-1)))&amp;0xFFFF; *PC = newPC; *PC = PC + 2 + (LL &amp; (carry-1));return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x90 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const newPC = (PC + 2 + (LL &amp; (carry-1)))&amp;0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL &amp; (carry-1));return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ 90</td><td class="s110" dir="ltr">UNBCC</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R90" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">91</div></th><td class="s103" dir="ltr">91 LL</td><td class="s190" dir="ltr">STA</td><td class="s191" dir="ltr">6</td><td class="s192" dir="ltr">($LL), Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s193"></td><td class="s4"></td><td class="s194" dir="ltr">LL</td><td class="s194" dir="ltr"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194" dir="ltr">zeroPageWord + Y</td><td class="s194" dir="ltr">A</td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x91 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); *PC = PC + 2; memory[(zeroPageWord + Y)&amp;0xFFFF] = A; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x91 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); *PC = PC + 2; memory[(zeroPageWord + Y)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x91 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); cpu.PC = PC + 2; memory[(zeroPageWord + Y)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s194" dir="ltr">writeByteAddress</td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s112" dir="ltr">BB 91</td><td class="s194">UNSTA</td><td class="s192" dir="ltr">$BB</td><td class="s4"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s9"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s192"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R91" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">92</div></th><td class="s103" dir="ltr">94 LL</td><td class="s156" dir="ltr">STY</td><td class="s157" dir="ltr">4</td><td class="s158" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s160" dir="ltr">Y</td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x94 { LL := memory[PC + 1]; *PC = PC + 2; memory[((LL + X) &amp; 0xFF)&amp;0xFFFF] = Y; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x94 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; *PC = PC + 2; memory[((LL + X) &amp; 0xFF)&amp;0xFFFF] = Y; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x94 ) { const LL = memory[(PC+1)&amp;0xFFFF]; cpu.PC = PC + 2; memory[((LL + X) &amp; 0xFF)&amp;0xFFFF] = Y; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr">writeByteAddress</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">BB 94</td><td class="s160">UNSTY</td><td class="s158" dir="ltr">$BB</td><td class="s4"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s158"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R92" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">93</div></th><td class="s103" dir="ltr">95 LL</td><td class="s190" dir="ltr">STA</td><td class="s191" dir="ltr">4</td><td class="s192" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s193"></td><td class="s4"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s194" dir="ltr">A</td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x95 { LL := memory[PC + 1]; *PC = PC + 2; memory[((LL + X) &amp; 0xFF)&amp;0xFFFF] = A; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x95 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; *PC = PC + 2; memory[((LL + X) &amp; 0xFF)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x95 ) { const LL = memory[(PC+1)&amp;0xFFFF]; cpu.PC = PC + 2; memory[((LL + X) &amp; 0xFF)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s194" dir="ltr">writeByteAddress</td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s112" dir="ltr">BB 95</td><td class="s194">UNSTA</td><td class="s192" dir="ltr">$BB</td><td class="s4"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s9"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s192"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R93" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">94</div></th><td class="s103" dir="ltr">96 LL</td><td class="s150" dir="ltr">STX</td><td class="s151" dir="ltr">4</td><td class="s152" dir="ltr">$LL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s153"></td><td class="s4"></td><td class="s154" dir="ltr">LL</td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s154" dir="ltr">zeroPageWord + Y</td><td class="s154" dir="ltr">X</td><td class="s154"></td><td class="s155"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x96 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); *PC = PC + 2; memory[(zeroPageWord + Y)&amp;0xFFFF] = X; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x96 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); *PC = PC + 2; memory[(zeroPageWord + Y)&amp;0xFFFF] = X; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x96 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); cpu.PC = PC + 2; memory[(zeroPageWord + Y)&amp;0xFFFF] = X; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s154" dir="ltr">writeByteAddress</td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s155"></td><td class="s5"></td><td class="s112" dir="ltr">BB 96</td><td class="s154">UNSTX</td><td class="s152" dir="ltr">$BB</td><td class="s4"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s9"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s154"></td><td class="s152"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R94" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">95</div></th><td class="s103" dir="ltr">98</td><td class="s113" dir="ltr">TYA</td><td class="s114" dir="ltr">2</td><td class="s115"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">Y</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x98 { result := Y; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x98 ) { unsigned int result = Y; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x98 ) { const result = Y; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">A</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR 98</td><td class="s117" dir="ltr">UNTYA</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R95" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">96</div></th><td class="s103" dir="ltr">99 LL HH</td><td class="s190" dir="ltr">STA</td><td class="s191" dir="ltr">5</td><td class="s192" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s193"></td><td class="s4"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s194" dir="ltr">HHLL + Y</td><td class="s194" dir="ltr">A</td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x99 { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL + Y)&amp;0xFFFF] = A; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x99 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); *PC = PC + 3; memory[(HHLL + Y)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x99 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); cpu.PC = PC + 3; memory[(HHLL + Y)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s194" dir="ltr">writeByteAddress</td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s112" dir="ltr">BB 99</td><td class="s194">UNSTA</td><td class="s192" dir="ltr">$BB</td><td class="s4"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s9"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s192"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R96" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">97</div></th><td class="s103" dir="ltr">9A</td><td class="s119" dir="ltr">TXS</td><td class="s196" dir="ltr">2</td><td class="s197" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s198"></td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199"></td><td class="s199"></td><td class="s200" dir="ltr">X</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s199" dir="ltr">result</td><td class="s200"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x9A { result := X; newSP := result; *SP = newSP; *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x9A ) { unsigned int result = X; unsigned char newSP = result; *SP = newSP; *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x9A ) { const result = X; const newSP = result; cpu.SP = newSP; cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s199"></td><td class="s199"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr">SP</td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s200"></td><td class="s5"></td><td class="s112" dir="ltr">RR 9A</td><td class="s199" dir="ltr">UNTXS</td><td class="s197" dir="ltr">$RR</td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s140"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s197" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R97" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">98</div></th><td class="s131" dir="ltr">9D LL HH</td><td class="s208" dir="ltr">STA</td><td class="s209" dir="ltr">5</td><td class="s210" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s211"></td><td class="s136"></td><td class="s212" dir="ltr"></td><td class="s212" dir="ltr"></td><td class="s212"></td><td class="s213"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s213" dir="ltr"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s213"></td><td class="s212" dir="ltr">HHLL + X</td><td class="s212" dir="ltr">A</td><td class="s212"></td><td class="s213"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0x9D { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL + X)&amp;0xFFFF] = A; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0x9D ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); *PC = PC + 3; memory[(HHLL + X)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0x9D ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); cpu.PC = PC + 3; memory[(HHLL + X)&amp;0xFFFF] = A; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s212" dir="ltr">writeByteAddress</td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s213"></td><td class="s139"></td><td class="s112" dir="ltr">BB 9D</td><td class="s212">UNSTA</td><td class="s210" dir="ltr">$BB</td><td class="s136"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s210"></td><td class="s140"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s212"></td><td class="s210"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R98" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">99</div></th><td class="s103" dir="ltr">A0 LL</td><td class="s113" dir="ltr">LDY</td><td class="s114" dir="ltr">2</td><td class="s115" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">LL</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xA0 { LL := memory[PC + 1]; result := LL; newY := result; *Y = newY; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xA0 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = LL; unsigned char newY = result; *Y = newY; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xA0 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = LL; const newY = result; cpu.Y = newY; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">Y</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR A0</td><td class="s117" dir="ltr">UNLDY</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s140"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R99" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">100</div></th><td class="s103" dir="ltr">A1</td><td class="s156" dir="ltr">LDA</td><td class="s157" dir="ltr">6</td><td class="s158" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr">LL + X</td><td class="s160" dir="ltr">zeroPageWord</td><td class="s160"></td><td class="s161" dir="ltr">readByte</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xA1 { zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xA1 ) { unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xA1 ) { const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR A1</td><td class="s160" dir="ltr">UNLDA</td><td class="s158" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s140"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R100" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">101</div></th><td class="s103" dir="ltr">A2 LL</td><td class="s119" dir="ltr">LDX</td><td class="s196" dir="ltr">2</td><td class="s197" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s198"></td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199"></td><td class="s199"></td><td class="s200" dir="ltr">LL</td><td class="s199"></td><td class="s199" dir="ltr">result</td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s199"></td><td class="s199" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200" dir="ltr">result &gt;&gt; 7</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xA2 { LL := memory[PC + 1]; result := LL; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xA2 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = LL; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xA2 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = LL; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s199"></td><td class="s199"></td><td class="s199" dir="ltr">SR</td><td class="s199" dir="ltr">X</td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr">zero, negative</td><td class="s200"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR A2</td><td class="s199" dir="ltr">UNLDX</td><td class="s197" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s197" dir="ltr"></td><td class="s140"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s197" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R101" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">102</div></th><td class="s103" dir="ltr">A4 LL</td><td class="s113" dir="ltr">LDY</td><td class="s114" dir="ltr">3</td><td class="s115" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">LL</td><td class="s117"></td><td class="s118" dir="ltr">readByte</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xA4 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xA4 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newY = result; *Y = newY; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xA4 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = readByte; const newY = result; cpu.Y = newY; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">Y</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR A4</td><td class="s117" dir="ltr">UNLDY</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s140"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R102" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">103</div></th><td class="s103" dir="ltr">A5 LL</td><td class="s156" dir="ltr">LDA</td><td class="s157" dir="ltr">3</td><td class="s158" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">LL</td><td class="s160"></td><td class="s161" dir="ltr">readByte</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xA5 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xA5 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xA5 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR A5</td><td class="s160" dir="ltr">UNLDA</td><td class="s158" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s140"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R103" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">104</div></th><td class="s103" dir="ltr">A6 LL</td><td class="s119" dir="ltr">LDX</td><td class="s196" dir="ltr">3</td><td class="s197" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s198"></td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr">LL</td><td class="s199"></td><td class="s200" dir="ltr">readByte</td><td class="s199"></td><td class="s199" dir="ltr">result</td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s199"></td><td class="s199" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200" dir="ltr">result &gt;&gt; 7</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xA6 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xA6 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xA6 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = readByte; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s199"></td><td class="s199"></td><td class="s199" dir="ltr">SR</td><td class="s199" dir="ltr">X</td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr">zero, negative</td><td class="s200"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR A6</td><td class="s199" dir="ltr">UNLDX</td><td class="s197" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s197" dir="ltr"></td><td class="s140"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s197" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R104" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">105</div></th><td class="s103" dir="ltr">A8</td><td class="s190" dir="ltr">TAY</td><td class="s191" dir="ltr">2</td><td class="s192"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s193"></td><td class="s4"></td><td class="s194" dir="ltr"></td><td class="s194"></td><td class="s194"></td><td class="s195" dir="ltr">A</td><td class="s194"></td><td class="s194"></td><td class="s194" dir="ltr">result</td><td class="s194"></td><td class="s195"></td><td class="s194"></td><td class="s194" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195" dir="ltr">result &gt;&gt; 7</td><td class="s194"></td><td class="s194"></td><td class="s194"></td><td class="s195"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xA8 { result := A; newY := result; *Y = newY; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xA8 ) { unsigned int result = A; unsigned char newY = result; *Y = newY; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xA8 ) { const result = A; const newY = result; cpu.Y = newY; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s194"></td><td class="s194"></td><td class="s194" dir="ltr">SR</td><td class="s194" dir="ltr">Y</td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr">zero, negative</td><td class="s195"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR A8</td><td class="s194" dir="ltr">UNTAY</td><td class="s192" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s192" dir="ltr"></td><td class="s140"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s194" dir="ltr"></td><td class="s192" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R105" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">106</div></th><td class="s103" dir="ltr">A9 LL</td><td class="s156" dir="ltr">LDA</td><td class="s157" dir="ltr">2</td><td class="s158" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">LL</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xA9 { LL := memory[PC + 1]; result := LL; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xA9 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = LL; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xA9 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = LL; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR A9</td><td class="s160" dir="ltr">UNLDA</td><td class="s158" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s140"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R106" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">107</div></th><td class="s103" dir="ltr">AA</td><td class="s174" dir="ltr">TAX</td><td class="s175" dir="ltr">2</td><td class="s176"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">A</td><td class="s178"></td><td class="s178" dir="ltr">result</td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178"></td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xAA { result := A; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xAA ) { unsigned int result = A; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xAA ) { const result = A; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr">X</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR AA</td><td class="s178" dir="ltr">UNTAX</td><td class="s176" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s140"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R107" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">108</div></th><td class="s103" dir="ltr">AC LL HH</td><td class="s113" dir="ltr">LDY</td><td class="s114" dir="ltr">4</td><td class="s115" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">HHLL</td><td class="s117"></td><td class="s118" dir="ltr">readByte</td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xAC { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xAC ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newY = result; *Y = newY; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xAC ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = readByte; const newY = result; cpu.Y = newY; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">Y</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR AC</td><td class="s117" dir="ltr">UNLDY</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s140"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R108" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">109</div></th><td class="s103" dir="ltr">AD LL HH</td><td class="s156" dir="ltr">LDA</td><td class="s157" dir="ltr">4</td><td class="s158" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">HHLL</td><td class="s160"></td><td class="s161" dir="ltr">readByte</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xAD { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xAD ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xAD ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR AD</td><td class="s160" dir="ltr">UNLDA</td><td class="s158" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s140"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R109" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">110</div></th><td class="s131" dir="ltr">AE LL HH</td><td class="s132" dir="ltr">LDX</td><td class="s214" dir="ltr">4</td><td class="s215" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s216"></td><td class="s136"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr">HHLL</td><td class="s217"></td><td class="s218" dir="ltr">readByte</td><td class="s217"></td><td class="s217" dir="ltr">result</td><td class="s217"></td><td class="s217"></td><td class="s218"></td><td class="s217"></td><td class="s217" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s217"></td><td class="s217"></td><td class="s217"></td><td class="s217"></td><td class="s218" dir="ltr">result &gt;&gt; 7</td><td class="s217"></td><td class="s217"></td><td class="s217"></td><td class="s218"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xAE { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xAE ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xAE ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = readByte; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s217"></td><td class="s217"></td><td class="s217" dir="ltr">SR</td><td class="s217" dir="ltr">X</td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr">zero, negative</td><td class="s218"></td><td class="s139"></td><td class="s112" dir="ltr">SS RR AE</td><td class="s217" dir="ltr">UNLDX</td><td class="s215" dir="ltr">$SS, $RR</td><td class="s136"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s215" dir="ltr"></td><td class="s140"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s215" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R110" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">111</div></th><td class="s103" dir="ltr">B0 LL</td><td class="s106" dir="ltr">BCS</td><td class="s107" dir="ltr">2**</td><td class="s108" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">PC + 2 + (LL &amp; (-carry))</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xB0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL &amp; (-carry)); *PC = newPC; *PC = PC + 2 + (LL &amp; (-carry));return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xB0 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int newPC = (PC + 2 + (LL &amp; (-carry)))&amp;0xFFFF; *PC = newPC; *PC = PC + 2 + (LL &amp; (-carry));return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xB0 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const newPC = (PC + 2 + (LL &amp; (-carry)))&amp;0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL &amp; (-carry));return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ B0</td><td class="s110" dir="ltr">UNBCS</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s140"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R111" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">112</div></th><td class="s103" dir="ltr">B1</td><td class="s156" dir="ltr">LDA</td><td class="s157" dir="ltr">5*</td><td class="s158" dir="ltr">($LL), Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr">LL</td><td class="s160" dir="ltr">zeroPageWord + Y</td><td class="s160"></td><td class="s161" dir="ltr">readByte</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xB1 { zeroPageWord := memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord + Y)&amp;0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xB1 ) { unsigned int zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xB1 ) { const zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR B1</td><td class="s160" dir="ltr">UNLDA</td><td class="s158" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s140"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R112" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">113</div></th><td class="s103" dir="ltr">B4</td><td class="s113" dir="ltr">LDY</td><td class="s114" dir="ltr">4</td><td class="s115" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s117"></td><td class="s118" dir="ltr">readByte</td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xB4 { readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xB4 ) { unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newY = result; *Y = newY; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xB4 ) { const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = readByte; const newY = result; cpu.Y = newY; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">Y</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR B4</td><td class="s117" dir="ltr">UNLDY</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s140"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R113" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">114</div></th><td class="s103" dir="ltr">B5 LL</td><td class="s156" dir="ltr">LDA</td><td class="s157" dir="ltr">4</td><td class="s158" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s160"></td><td class="s161" dir="ltr">readByte</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xB5 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xB5 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xB5 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR B5</td><td class="s160" dir="ltr">UNLDA</td><td class="s158" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s140"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R114" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">115</div></th><td class="s103" dir="ltr">B6</td><td class="s119" dir="ltr">LDX</td><td class="s196" dir="ltr">4</td><td class="s197" dir="ltr">$LL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s198"></td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr">(LL + Y) &amp; 0xFF</td><td class="s199"></td><td class="s200" dir="ltr">readByte</td><td class="s199"></td><td class="s199" dir="ltr">result</td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s199"></td><td class="s199" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200" dir="ltr">result &gt;&gt; 7</td><td class="s199"></td><td class="s199"></td><td class="s199"></td><td class="s200"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xB6 { readByte := memory[((LL + Y) &amp; 0xFF)&amp;0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xB6 ) { unsigned char readByte = memory[((LL + Y) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xB6 ) { const readByte = memory[((LL + Y) &amp; 0xFF)&amp;0xFFFF]; const result = readByte; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s199"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr">SR</td><td class="s199" dir="ltr">X</td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr">zero, negative</td><td class="s200"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR B6</td><td class="s199" dir="ltr">UNLDX</td><td class="s197" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s197" dir="ltr"></td><td class="s140"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s199" dir="ltr"></td><td class="s197" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R115" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">116</div></th><td class="s103" dir="ltr">B8</td><td class="s106" dir="ltr">CLV</td><td class="s107" dir="ltr">2</td><td class="s108"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">0x0</td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xB8 { carry := SR&amp;1; zero := (SR&gt;&gt;1)&amp;1; interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := 0x0;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xB8 ) { unsigned char carry = SR&amp;1; unsigned char zero = (SR&gt;&gt;1)&amp;1; unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = 0x0;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xB8 ) { const carry = SR&amp;1; const zero = (SR&gt;&gt;1)&amp;1; const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = 0x0;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">overflow</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">SS B8</td><td class="s110" dir="ltr">UNCLV</td><td class="s108" dir="ltr">$SS</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s140"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R116" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">117</div></th><td class="s103" dir="ltr">B9 LL HH</td><td class="s156" dir="ltr">LDA</td><td class="s157" dir="ltr">4*</td><td class="s158" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">HHLL + Y</td><td class="s160"></td><td class="s161" dir="ltr">readByte</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xB9 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&amp;0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xB9 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + Y)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xB9 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + Y)&amp;0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR B9</td><td class="s160" dir="ltr">UNLDA</td><td class="s158" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s140"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R117" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">118</div></th><td class="s103" dir="ltr">BA</td><td class="s125" dir="ltr">TSX</td><td class="s126" dir="ltr">2</td><td class="s127" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s128"></td><td class="s4"></td><td class="s129" dir="ltr"></td><td class="s129"></td><td class="s129"></td><td class="s130" dir="ltr">SP</td><td class="s129"></td><td class="s129" dir="ltr">result</td><td class="s129"></td><td class="s129"></td><td class="s130"></td><td class="s129"></td><td class="s129" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s130" dir="ltr">result &gt;&gt; 7</td><td class="s129"></td><td class="s129"></td><td class="s129"></td><td class="s130"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xBA { result := SP; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xBA ) { unsigned int result = SP; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xBA ) { const result = SP; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s129"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr">SR</td><td class="s129" dir="ltr">X</td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr">zero, negative</td><td class="s130"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR BA</td><td class="s129" dir="ltr">UNTSX</td><td class="s127" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s127" dir="ltr"></td><td class="s140"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s129" dir="ltr"></td><td class="s127" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R118" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">119</div></th><td class="s103" dir="ltr">BC</td><td class="s113" dir="ltr">LDY</td><td class="s114" dir="ltr">4*</td><td class="s115" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">HHLL + X</td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117"></td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xBC { readByte := memory[(HHLL + X)&amp;0xFFFF]; newY := result; *Y = newY; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xBC ) { unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned char newY = result; *Y = newY; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xBC ) { const readByte = memory[(HHLL + X)&amp;0xFFFF]; const newY = result; cpu.Y = newY; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr">Y</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">zero, negative</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR BC</td><td class="s117" dir="ltr">UNLDY</td><td class="s115" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s140"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R119" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">120</div></th><td class="s103" dir="ltr">BD LL HH</td><td class="s156" dir="ltr">LDA</td><td class="s157" dir="ltr">4*</td><td class="s158" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">HHLL + X</td><td class="s160"></td><td class="s161" dir="ltr">readByte</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xBD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xBD ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xBD ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr">A</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">zero, negative</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS RR BD</td><td class="s160" dir="ltr">UNLDA</td><td class="s158" dir="ltr">$SS, $RR</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s140"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R120" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">121</div></th><td class="s131" dir="ltr">BE</td><td class="s132" dir="ltr">LDX</td><td class="s214" dir="ltr">4*</td><td class="s215" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s216"></td><td class="s136"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr">HHLL + Y</td><td class="s217"></td><td class="s218" dir="ltr">readByte</td><td class="s217"></td><td class="s217" dir="ltr">result</td><td class="s217"></td><td class="s217"></td><td class="s218"></td><td class="s217"></td><td class="s217" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s217"></td><td class="s217"></td><td class="s217"></td><td class="s217"></td><td class="s218" dir="ltr">result &gt;&gt; 7</td><td class="s217"></td><td class="s217"></td><td class="s217"></td><td class="s218"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xBE { readByte := memory[(HHLL + Y)&amp;0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xBE ) { unsigned char readByte = memory[(HHLL + Y)&amp;0xFFFF]; unsigned int result = readByte; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xBE ) { const readByte = memory[(HHLL + Y)&amp;0xFFFF]; const result = readByte; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s217"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr">SR</td><td class="s217" dir="ltr">X</td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr">zero, negative</td><td class="s218"></td><td class="s139"></td><td class="s112" dir="ltr">SS RR BE</td><td class="s217" dir="ltr">UNLDX</td><td class="s215" dir="ltr">$SS, $RR</td><td class="s136"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s215" dir="ltr"></td><td class="s140"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s217" dir="ltr"></td><td class="s215" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R121" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">122</div></th><td class="s103" dir="ltr">C0 LL</td><td class="s174" dir="ltr">CPY</td><td class="s175" dir="ltr">2</td><td class="s176" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">Y - LL</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xC0 { LL := memory[PC + 1]; result := Y - LL; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xC0 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = Y - LL; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xC0 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = Y - LL; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS C0</td><td class="s178" dir="ltr">UNCPY</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s140"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R122" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">123</div></th><td class="s103" dir="ltr">C1 LL</td><td class="s174" dir="ltr">CMP</td><td class="s175" dir="ltr">4</td><td class="s176" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177" dir="ltr"></td><td class="s4"></td><td class="s178" dir="ltr">LL + X</td><td class="s178" dir="ltr">zeroPageWord</td><td class="s178" dir="ltr"></td><td class="s179" dir="ltr">A - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xC1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := A - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xC1 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xC1 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = A - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS C1</td><td class="s178" dir="ltr">UNCMP</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s140"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R123" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">124</div></th><td class="s103" dir="ltr">C4 LL</td><td class="s174" dir="ltr">CPY</td><td class="s175" dir="ltr">3</td><td class="s176" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">LL</td><td class="s178"></td><td class="s179" dir="ltr">Y - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xC4 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := Y - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xC4 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = Y - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xC4 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = Y - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS C4</td><td class="s178" dir="ltr">UNCPY</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s140"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R124" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">125</div></th><td class="s103" dir="ltr">C5 LL</td><td class="s174" dir="ltr">CMP</td><td class="s175" dir="ltr">3</td><td class="s176" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">LL</td><td class="s178"></td><td class="s179" dir="ltr">A - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xC5 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := A - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xC5 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xC5 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = A - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS C5</td><td class="s178" dir="ltr">UNCMP</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R125" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">126</div></th><td class="s103" dir="ltr">C6 LL</td><td class="s113" dir="ltr">DEC</td><td class="s114" dir="ltr">5</td><td class="s115" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">LL</td><td class="s117"></td><td class="s118" dir="ltr">readByte - 1</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117" dir="ltr">readByteAddress</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xC6 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := readByte - 1; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xC6 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = readByte - 1; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xC6 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = readByte - 1; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">negative, zero</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS C6</td><td class="s117" dir="ltr">UNDEC</td><td class="s115" dir="ltr">$SS</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R126" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">127</div></th><td class="s103" dir="ltr">C8</td><td class="s180" dir="ltr">INY</td><td class="s120" dir="ltr">2</td><td class="s121"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122"></td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">Y + 1</td><td class="s123"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">result</td><td class="s123"></td><td class="s124"></td><td class="s123"></td><td class="s123" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">result &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xC8 { result := Y + 1; newY := result; *Y = newY; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xC8 ) { unsigned int result = Y + 1; unsigned char newY = result; *Y = newY; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xC8 ) { const result = Y + 1; const newY = result; cpu.Y = newY; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SR</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">carry, zero</td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">SS C8</td><td class="s123" dir="ltr">UNINY</td><td class="s121" dir="ltr">$SS</td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s121" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R127" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">128</div></th><td class="s103" dir="ltr">C9 LL</td><td class="s174" dir="ltr">CMP</td><td class="s175" dir="ltr">2</td><td class="s176" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177" dir="ltr"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s179" dir="ltr">A - LL</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xC9 { LL := memory[PC + 1]; result := A - LL; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xC9 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = A - LL; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xC9 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = A - LL; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS C9</td><td class="s178" dir="ltr">UNCMP</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R128" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">129</div></th><td class="s103" dir="ltr">CA</td><td class="s113" dir="ltr">DEX</td><td class="s114" dir="ltr">2</td><td class="s115" dir="ltr"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s118" dir="ltr">X - 1</td><td class="s117"></td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xCA { result := X - 1; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xCA ) { unsigned int result = X - 1; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xCA ) { const result = X - 1; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">negative, zero</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS CA</td><td class="s117" dir="ltr">UNDEX</td><td class="s115" dir="ltr">$SS</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R129" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">130</div></th><td class="s103" dir="ltr">CC LL HH</td><td class="s174" dir="ltr">CPY</td><td class="s175" dir="ltr">4</td><td class="s176" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">HHLL</td><td class="s178"></td><td class="s179" dir="ltr">Y - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xCC { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := Y - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xCC ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = Y - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xCC ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = Y - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS CC</td><td class="s178" dir="ltr">UNCPY</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R130" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">131</div></th><td class="s103" dir="ltr">CD LL HH</td><td class="s174" dir="ltr">CMP</td><td class="s175" dir="ltr">4</td><td class="s176" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">HHLL</td><td class="s178"></td><td class="s179" dir="ltr">A - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xCD { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := A - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xCD ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xCD ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = A - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS CD</td><td class="s178" dir="ltr">UNCMP</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R131" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">132</div></th><td class="s131" dir="ltr">CE LL HH</td><td class="s219" dir="ltr">DEC</td><td class="s220" dir="ltr">6</td><td class="s221" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s222"></td><td class="s136"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr">HHLL</td><td class="s223"></td><td class="s224" dir="ltr">readByte - 1</td><td class="s223"></td><td class="s223"></td><td class="s223"></td><td class="s223"></td><td class="s224"></td><td class="s223"></td><td class="s223" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s223"></td><td class="s223"></td><td class="s223"></td><td class="s223"></td><td class="s224" dir="ltr">result &gt;&gt; 7</td><td class="s223" dir="ltr">readByteAddress</td><td class="s223" dir="ltr">result</td><td class="s223"></td><td class="s224"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xCE { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := readByte - 1; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xCE ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = readByte - 1; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xCE ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = readByte - 1; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s223" dir="ltr"></td><td class="s223"></td><td class="s223" dir="ltr">SR</td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr">negative, zero</td><td class="s224"></td><td class="s139"></td><td class="s112" dir="ltr">SS CE</td><td class="s223" dir="ltr">UNDEC</td><td class="s221" dir="ltr">$SS</td><td class="s136"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s140"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s221" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R132" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">133</div></th><td class="s187" dir="ltr">D0 LL</td><td class="s106" dir="ltr">BNE</td><td class="s107" dir="ltr">2**</td><td class="s108" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">PC + 2 + (LL &amp; (zero-1))</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xD0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL &amp; (zero-1)); *PC = newPC; *PC = PC + 2 + (LL &amp; (zero-1));return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xD0 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int newPC = (PC + 2 + (LL &amp; (zero-1)))&amp;0xFFFF; *PC = newPC; *PC = PC + 2 + (LL &amp; (zero-1));return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xD0 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const newPC = (PC + 2 + (LL &amp; (zero-1)))&amp;0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL &amp; (zero-1));return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ D0</td><td class="s110" dir="ltr">UNBNE</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R133" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">134</div></th><td class="s187" dir="ltr">D1 LL</td><td class="s174" dir="ltr">CMP</td><td class="s175" dir="ltr">4</td><td class="s176" dir="ltr">($LL), Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177" dir="ltr"></td><td class="s4"></td><td class="s178" dir="ltr">LL</td><td class="s178" dir="ltr">zeroPageWord + YY</td><td class="s178" dir="ltr"></td><td class="s179" dir="ltr">A - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xD1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord + YY)&amp;0xFFFF]; result := A - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xD1 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord + YY)&amp;0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xD1 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL)&amp;0xFF] + (memory[((LL)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord + YY)&amp;0xFFFF]; const result = A - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS D1</td><td class="s178" dir="ltr">UNCMP</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R134" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">135</div></th><td class="s187" dir="ltr">D5 LL</td><td class="s174" dir="ltr">CMP</td><td class="s175" dir="ltr">4</td><td class="s176" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177" dir="ltr"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s178" dir="ltr"></td><td class="s179" dir="ltr">A - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xD5 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := A - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xD5 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xD5 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = A - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS D5</td><td class="s178" dir="ltr">UNCMP</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R135" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">136</div></th><td class="s187" dir="ltr">D6 LL</td><td class="s113" dir="ltr">DEC</td><td class="s114" dir="ltr">6</td><td class="s115" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s142"></td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s117"></td><td class="s118" dir="ltr">readByte - 1</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118"></td><td class="s117"></td><td class="s117" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s117"></td><td class="s118" dir="ltr">result &gt;&gt; 7</td><td class="s117" dir="ltr">readByteAddress</td><td class="s117" dir="ltr">result</td><td class="s117"></td><td class="s118"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xD6 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := readByte - 1; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xD6 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = readByte - 1; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xD6 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = readByte - 1; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117"></td><td class="s117" dir="ltr">SR</td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr">negative, zero</td><td class="s118"></td><td class="s5"></td><td class="s112" dir="ltr">SS D6</td><td class="s117" dir="ltr">UNDEC</td><td class="s115" dir="ltr">$SS</td><td class="s4"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s9"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s117" dir="ltr"></td><td class="s115" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R136" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">137</div></th><td class="s187" dir="ltr">D8</td><td class="s106" dir="ltr">CLD</td><td class="s107" dir="ltr">2</td><td class="s108"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">0x0</td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xD8 { carry := SR&amp;1; zero := (SR&gt;&gt;1)&amp;1; interrupt := (SR&gt;&gt;2)&amp;1; decimal := 0x0;overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xD8 ) { unsigned char carry = SR&amp;1; unsigned char zero = (SR&gt;&gt;1)&amp;1; unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = 0x0;unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xD8 ) { const carry = SR&amp;1; const zero = (SR&gt;&gt;1)&amp;1; const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = 0x0;const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">decimal</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">SS D8</td><td class="s110" dir="ltr">UNCLD</td><td class="s108" dir="ltr">$SS</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R137" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">138</div></th><td class="s187" dir="ltr">D9 LL HH</td><td class="s174" dir="ltr">CMP</td><td class="s175" dir="ltr">4*</td><td class="s176" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">HHLL + Y</td><td class="s178"></td><td class="s179" dir="ltr">A - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xD9 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&amp;0xFFFF]; result := A - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xD9 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + Y)&amp;0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xD9 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + Y)&amp;0xFFFF]; const result = A - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS D9</td><td class="s178" dir="ltr">UNCMP</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R138" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">139</div></th><td class="s187" dir="ltr">DD LL HH</td><td class="s174" dir="ltr">CMP</td><td class="s175" dir="ltr">4*</td><td class="s176" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">HHLL + X</td><td class="s178"></td><td class="s179" dir="ltr">A - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xDD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := A - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xDD ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xDD ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = A - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS DD</td><td class="s178" dir="ltr">UNCMP</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R139" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">140</div></th><td class="s143" dir="ltr">DE LL HH</td><td class="s219" dir="ltr">DEC</td><td class="s220" dir="ltr">7</td><td class="s221" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s222"></td><td class="s136"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr">HHLL + X</td><td class="s223"></td><td class="s224" dir="ltr">readByte - 1</td><td class="s223"></td><td class="s223"></td><td class="s223"></td><td class="s223"></td><td class="s224"></td><td class="s223"></td><td class="s223" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s223"></td><td class="s223"></td><td class="s223"></td><td class="s223"></td><td class="s224" dir="ltr">result &gt;&gt; 7</td><td class="s223" dir="ltr">readByteAddress</td><td class="s223" dir="ltr">result</td><td class="s223"></td><td class="s224"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xDE { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := readByte - 1; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xDE ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = readByte - 1; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xDE ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = readByte - 1; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s223" dir="ltr"></td><td class="s223"></td><td class="s223" dir="ltr">SR</td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr">negative, zero</td><td class="s224"></td><td class="s139"></td><td class="s112" dir="ltr">SS DE</td><td class="s223" dir="ltr">UNDEC</td><td class="s221" dir="ltr">$SS</td><td class="s136"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s140"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s223" dir="ltr"></td><td class="s221" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R140" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">141</div></th><td class="s103" dir="ltr">E0 LL</td><td class="s174" dir="ltr">CPX</td><td class="s175" dir="ltr">2</td><td class="s176" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">X - LL</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xE0 { LL := memory[PC + 1]; result := X - LL; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xE0 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = X - LL; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xE0 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = X - LL; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS E0</td><td class="s178" dir="ltr">UNCPX</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R141" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">142</div></th><td class="s103" dir="ltr">E1 LL</td><td class="s168" dir="ltr">SBC</td><td class="s169" dir="ltr">6</td><td class="s170" dir="ltr">($LL, X)</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr">LL + X</td><td class="s172" dir="ltr">zeroPageWord</td><td class="s172"></td><td class="s173" dir="ltr">A - readByte - (carry^1)</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172" dir="ltr">???</td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">???</td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xE1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord)&amp;0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xE1 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord)&amp;0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xE1 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord)&amp;0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ???;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">???</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">E1</td><td class="s172" dir="ltr">UNSBC</td><td class="s170" dir="ltr"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R142" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">143</div></th><td class="s103" dir="ltr">E4 LL</td><td class="s174" dir="ltr">CPX</td><td class="s175" dir="ltr">3</td><td class="s176" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">LL</td><td class="s178"></td><td class="s179" dir="ltr">X - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xE4 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := X - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xE4 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = X - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xE4 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = X - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS E4</td><td class="s178" dir="ltr">UNCPX</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R143" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">144</div></th><td class="s103" dir="ltr">E5 LL</td><td class="s168" dir="ltr">SBC</td><td class="s169" dir="ltr">3</td><td class="s170" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">LL</td><td class="s172"></td><td class="s173" dir="ltr">A - readByte - (carry^1)</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172" dir="ltr">???</td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">???</td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xE5 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xE5 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xE5 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ???;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">???</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">E5</td><td class="s172" dir="ltr">UNSBC</td><td class="s170" dir="ltr"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R144" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">145</div></th><td class="s103" dir="ltr">E6 LL</td><td class="s156" dir="ltr">INC</td><td class="s157" dir="ltr">5</td><td class="s158" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">LL</td><td class="s160"></td><td class="s161" dir="ltr">readByte + 1</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160" dir="ltr">readByteAddress</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xE6 { LL := memory[PC + 1]; readByte := memory[(LL)&amp;0xFFFF]; result := readByte + 1; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xE6 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[(LL)&amp;0xFFFF]; unsigned int result = readByte + 1; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xE6 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[(LL)&amp;0xFFFF]; const result = readByte + 1; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS E6</td><td class="s160" dir="ltr">UNINC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R145" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">146</div></th><td class="s103" dir="ltr">E8</td><td class="s180" dir="ltr">INX</td><td class="s120" dir="ltr">2</td><td class="s121"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s122"></td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">X + 1</td><td class="s123"></td><td class="s123" dir="ltr">result</td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s123"></td><td class="s123" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124" dir="ltr">result &gt;&gt; 7</td><td class="s123"></td><td class="s123"></td><td class="s123"></td><td class="s124"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xE8 { result := X + 1; newX := result; *X = newX; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xE8 ) { unsigned int result = X + 1; unsigned char newX = result; *X = newX; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xE8 ) { const result = X + 1; const newX = result; cpu.X = newX; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s123"></td><td class="s123"></td><td class="s123" dir="ltr">SR</td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr">carry, zero</td><td class="s124"></td><td class="s5"></td><td class="s112" dir="ltr">SS E8</td><td class="s123" dir="ltr">UNINX</td><td class="s121" dir="ltr">$SS</td><td class="s4"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s9"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s123" dir="ltr"></td><td class="s121" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R146" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">147</div></th><td class="s103" dir="ltr">E9 LL</td><td class="s168" dir="ltr">SBC</td><td class="s169" dir="ltr">2</td><td class="s170" dir="ltr">#$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172"></td><td class="s172"></td><td class="s173" dir="ltr">A - LL - (carry^1)</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172" dir="ltr">???</td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">???</td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xE9 { LL := memory[PC + 1]; result := A - LL - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xE9 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int result = A - LL - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xE9 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const result = A - LL - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ???;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">???</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">E9</td><td class="s172" dir="ltr">UNSBC</td><td class="s170" dir="ltr"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R147" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">148</div></th><td class="s103" dir="ltr">EA</td><td class="s106" dir="ltr">NOP</td><td class="s225" dir="ltr">2</td><td class="s226"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s227"></td><td class="s4"></td><td class="s228" dir="ltr"></td><td class="s228"></td><td class="s228"></td><td class="s229"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s229"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s229"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s229"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xEA { *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xEA ) { *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xEA ) { cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s229"></td><td class="s5"></td><td class="s112" dir="ltr">EA</td><td class="s228">UNNOP</td><td class="s226"></td><td class="s4"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s9"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s228"></td><td class="s226"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R148" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">149</div></th><td class="s103" dir="ltr">EC LL HH</td><td class="s174" dir="ltr">CPX</td><td class="s175" dir="ltr">3</td><td class="s176" dir="ltr">$LLHH</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s177"></td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">HHLL</td><td class="s178"></td><td class="s179" dir="ltr">X - readByte</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s178" dir="ltr">1 - (result &gt;&gt; 7)</td><td class="s178" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179" dir="ltr">result &gt;&gt; 7</td><td class="s178"></td><td class="s178"></td><td class="s178"></td><td class="s179"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xEC { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := X - readByte; carry := 1 - (result &gt;&gt; 7);zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xEC ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = X - readByte; unsigned char carry = 1 - (result &gt;&gt; 7);unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xEC ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = X - readByte; const carry = 1 - (result &gt;&gt; 7);const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s178"></td><td class="s178"></td><td class="s178" dir="ltr">SR</td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr">carry, zero, negative</td><td class="s179"></td><td class="s5"></td><td class="s112" dir="ltr">SS EC</td><td class="s178" dir="ltr">UNCPX</td><td class="s176" dir="ltr">$SS</td><td class="s4"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s9"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s178" dir="ltr"></td><td class="s176" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R149" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">150</div></th><td class="s103" dir="ltr">ED LL HH</td><td class="s168" dir="ltr">SBC</td><td class="s169" dir="ltr">4</td><td class="s170" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">HHLL</td><td class="s172"></td><td class="s173" dir="ltr">A - readByte - (carry^1)</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172" dir="ltr">???</td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">???</td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xED { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xED ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xED ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ???;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">???</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">ED</td><td class="s172" dir="ltr">UNSBC</td><td class="s170" dir="ltr"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R150" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">151</div></th><td class="s131" dir="ltr">EE LL HH</td><td class="s162" dir="ltr">INC</td><td class="s163" dir="ltr">6</td><td class="s164" dir="ltr">$HHLL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s165"></td><td class="s136"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr">HHLL</td><td class="s166"></td><td class="s167" dir="ltr">readByte + 1</td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s167"></td><td class="s166"></td><td class="s166" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s167" dir="ltr">result &gt;&gt; 7</td><td class="s166" dir="ltr">readByteAddress</td><td class="s166" dir="ltr">result</td><td class="s166"></td><td class="s167"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xEE { LL := memory[PC + 1]; readByte := memory[(HHLL)&amp;0xFFFF]; result := readByte + 1; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xEE ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL)&amp;0xFFFF]; unsigned int result = readByte + 1; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xEE ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL)&amp;0xFFFF]; const result = readByte + 1; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s166"></td><td class="s166"></td><td class="s166" dir="ltr">SR</td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr">carry, zero</td><td class="s167"></td><td class="s139"></td><td class="s112" dir="ltr">SS EE</td><td class="s166" dir="ltr">UNINC</td><td class="s164" dir="ltr">$SS</td><td class="s136"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s140"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s164" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R151" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">152</div></th><td class="s103" dir="ltr">F0 LL</td><td class="s106" dir="ltr">BEQ</td><td class="s107" dir="ltr">2**</td><td class="s108" dir="ltr">$LL</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111" dir="ltr">PC + 2 + (LL &amp; (-zero))</td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xF0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL &amp; (-zero)); *PC = newPC; *PC = PC + 2 + (LL &amp; (-zero));return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xF0 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int newPC = (PC + 2 + (LL &amp; (-zero)))&amp;0xFFFF; *PC = newPC; *PC = PC + 2 + (LL &amp; (-zero));return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xF0 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const newPC = (PC + 2 + (LL &amp; (-zero)))&amp;0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL &amp; (-zero));return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">PC</td><td class="s110" dir="ltr"></td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">PP QQ F0</td><td class="s110" dir="ltr">UNBEQ</td><td class="s108" dir="ltr">$QQPP</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R152" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">153</div></th><td class="s103" dir="ltr">F1</td><td class="s168" dir="ltr">SBC</td><td class="s169" dir="ltr">5*</td><td class="s170" dir="ltr">($LL), Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr">LL + X</td><td class="s172" dir="ltr">zeroPageWord + Y</td><td class="s172"></td><td class="s173" dir="ltr">A - readByte - (carry^1)</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172" dir="ltr">???</td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">???</td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xF1 { zeroPageWord := memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); readByte := memory[(zeroPageWord + Y)&amp;0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xF1 ) { unsigned int zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); unsigned char readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xF1 ) { const zeroPageWord = memory[(LL + X)&amp;0xFF] + (memory[((LL + X)+1)&amp;0xFF]&lt;&lt;8); const readByte = memory[(zeroPageWord + Y)&amp;0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ???;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">???</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS F1</td><td class="s172" dir="ltr">UNSBC</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R153" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">154</div></th><td class="s103" dir="ltr">F5 LL</td><td class="s168" dir="ltr">SBC</td><td class="s169" dir="ltr">4</td><td class="s170" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s172"></td><td class="s173" dir="ltr">A - readByte - (carry^1)</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172" dir="ltr">???</td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">???</td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xF5 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xF5 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xF5 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ???;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">???</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS F5</td><td class="s172" dir="ltr">UNSBC</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R154" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">155</div></th><td class="s103" dir="ltr">F6 LL</td><td class="s156" dir="ltr">INC</td><td class="s157" dir="ltr">6</td><td class="s158" dir="ltr">$LL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s159" dir="ltr"></td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">(LL + X) &amp; 0xFF</td><td class="s160" dir="ltr"></td><td class="s161" dir="ltr">readByte + 1</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161"></td><td class="s160"></td><td class="s160" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s160"></td><td class="s161" dir="ltr">result &gt;&gt; 7</td><td class="s160" dir="ltr">readByteAddress</td><td class="s160" dir="ltr">result</td><td class="s160"></td><td class="s161"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xF6 { LL := memory[PC + 1]; readByte := memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; result := readByte + 1; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xF6 ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned char readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; unsigned int result = readByte + 1; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xF6 ) { const LL = memory[(PC+1)&amp;0xFFFF]; const readByte = memory[((LL + X) &amp; 0xFF)&amp;0xFFFF]; const result = readByte + 1; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 2; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s160"></td><td class="s160"></td><td class="s160" dir="ltr">SR</td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr">carry, zero</td><td class="s161"></td><td class="s5"></td><td class="s112" dir="ltr">SS F6</td><td class="s160" dir="ltr">UNINC</td><td class="s158" dir="ltr">$SS</td><td class="s4"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s9"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s160" dir="ltr"></td><td class="s158" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R155" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">156</div></th><td class="s103" dir="ltr">F8</td><td class="s106" dir="ltr">SED</td><td class="s107" dir="ltr">2</td><td class="s108"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s141"></td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">0x1</td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s110"></td><td class="s110"></td><td class="s110"></td><td class="s111"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xF8 { carry := SR&amp;1; zero := (SR&gt;&gt;1)&amp;1; interrupt := (SR&gt;&gt;2)&amp;1; decimal := 0x1;overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xF8 ) { unsigned char carry = SR&amp;1; unsigned char zero = (SR&gt;&gt;1)&amp;1; unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = 0x1;unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xF8 ) { const carry = SR&amp;1; const zero = (SR&gt;&gt;1)&amp;1; const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = 0x1;const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s110"></td><td class="s110"></td><td class="s110" dir="ltr">SR</td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr">decimal</td><td class="s111"></td><td class="s5"></td><td class="s112" dir="ltr">SS F8</td><td class="s110" dir="ltr">UNSED</td><td class="s108" dir="ltr">$SS</td><td class="s4"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s9"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s110" dir="ltr"></td><td class="s108" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R156" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">157</div></th><td class="s103" dir="ltr">F9</td><td class="s168" dir="ltr">SBC</td><td class="s169" dir="ltr">4*</td><td class="s170" dir="ltr">$HHLL, Y</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">HHLL + Y</td><td class="s172"></td><td class="s173" dir="ltr">A - readByte - (carry^1)</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172" dir="ltr">???</td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">???</td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xF9 { readByte := memory[(HHLL + Y)&amp;0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xF9 ) { unsigned char readByte = memory[(HHLL + Y)&amp;0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xF9 ) { const readByte = memory[(HHLL + Y)&amp;0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ???;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 1; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">???</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS F9</td><td class="s172" dir="ltr">UNSBC</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R157" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">158</div></th><td class="s103" dir="ltr">FD LL HH</td><td class="s168" dir="ltr">SBC</td><td class="s169" dir="ltr">4*</td><td class="s170" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s171"></td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">HHLL + X</td><td class="s172"></td><td class="s173" dir="ltr">A - readByte - (carry^1)</td><td class="s172" dir="ltr">result</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s172" dir="ltr">???</td><td class="s172" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">???</td><td class="s173" dir="ltr">result &gt;&gt; 7</td><td class="s172"></td><td class="s172"></td><td class="s172"></td><td class="s173"></td><td class="s5"></td><td class="s4"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xFD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xFD ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = ???;*SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xFD ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = ???;cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s172"></td><td class="s172"></td><td class="s172" dir="ltr">SR</td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr">???</td><td class="s173"></td><td class="s5"></td><td class="s112" dir="ltr">SS FD</td><td class="s172" dir="ltr">UNSBC</td><td class="s170" dir="ltr">$SS</td><td class="s4"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s9"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s172" dir="ltr"></td><td class="s170" dir="ltr"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R158" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">159</div></th><td class="s131" dir="ltr">FE LL HH</td><td class="s162" dir="ltr">INC</td><td class="s163" dir="ltr">7</td><td class="s164" dir="ltr">$HHLL, X</td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s165"></td><td class="s136"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr">HHLL + X</td><td class="s166"></td><td class="s167" dir="ltr">readByte + 1</td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s167"></td><td class="s166"></td><td class="s166" dir="ltr">(result | -result) &gt;&gt; 7</td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s166"></td><td class="s167" dir="ltr">result &gt;&gt; 7</td><td class="s166" dir="ltr">readByteAddress</td><td class="s166" dir="ltr">result</td><td class="s166"></td><td class="s167"></td><td class="s139"></td><td class="s136"></td><td class="s97 softmerge"><div class="softmerge-inner" style="width:193px;left:-1px">  if instruction == 0xFE { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&amp;0xFFFF]; result := readByte + 1; carry := SR&amp;1; zero := (result | -result) &gt;&gt; 7;interrupt := (SR&gt;&gt;2)&amp;1; decimal := (SR&gt;&gt;3)&amp;1; overflow := (SR&gt;&gt;6)&amp;1; negative := (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true }</div></td><td class="s98"></td><td class="s99 softmerge"><div class="softmerge-inner" style="width:205px;left:-1px">  if( instruction == 0xFE ) { unsigned char LL = memory[(PC+1)&amp;0xFFFF]; unsigned int HH = memory[(PC+2)&amp;0xFFFF]; unsigned int HHLL = LL + (HH&lt;&lt;8); unsigned char readByte = memory[(HHLL + X)&amp;0xFFFF]; unsigned int result = readByte + 1; unsigned char carry = SR&amp;1; unsigned char zero = (result | -result) &gt;&gt; 7;unsigned char interrupt = (SR&gt;&gt;2)&amp;1; unsigned char decimal = (SR&gt;&gt;3)&amp;1; unsigned char overflow = (SR&gt;&gt;6)&amp;1; unsigned char negative = (SR&gt;&gt;7)&amp;1; *SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); *PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s100 softmerge"><div class="softmerge-inner" style="width:228px;left:-1px">  if( instruction == 0xFE ) { const LL = memory[(PC+1)&amp;0xFFFF]; const HH = memory[(PC+2)&amp;0xFFFF]; const HHLL = LL + (HH&lt;&lt;8); const readByte = memory[(HHLL + X)&amp;0xFFFF]; const result = readByte + 1; const carry = SR&amp;1; const zero = (result | -result) &gt;&gt; 7;const interrupt = (SR&gt;&gt;2)&amp;1; const decimal = (SR&gt;&gt;3)&amp;1; const overflow = (SR&gt;&gt;6)&amp;1; const negative = (SR&gt;&gt;7)&amp;1; cpu.SR = carry + (zero&lt;&lt;1) + (interrupt&lt;&lt;2) + (decimal&lt;&lt;3) + (overflow&lt;&lt;6) + (negative&lt;&lt;7); cpu.PC = PC + 3; memory[(readByteAddress)&amp;0xFFFF] = result; return true; }</div></td><td class="s98"></td><td class="s101" dir="ltr"></td><td class="s140"></td><td class="s166"></td><td class="s166"></td><td class="s166" dir="ltr">SR</td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr">carry, zero</td><td class="s167"></td><td class="s139"></td><td class="s112" dir="ltr">SS FE</td><td class="s166" dir="ltr">UNINC</td><td class="s164" dir="ltr">$SS</td><td class="s136"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s140"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s166" dir="ltr"></td><td class="s164" dir="ltr"></td><td class="s136"></td></tr><tr style="height: 20px"><th id="0R159" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">160</div></th><td class="s103"></td><td class="s104"></td><td class="s105"></td><td class="s9"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s5"></td><td class="s4"></td><td class="s230" dir="ltr">  return false</td><td class="s101" dir="ltr"></td><td class="s231" dir="ltr">  return false;</td><td class="s101" dir="ltr"></td><td class="s232" dir="ltr">  return false</td><td class="s101" dir="ltr"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R160" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">161</div></th><td class="s103"></td><td class="s104"></td><td class="s105"></td><td class="s9"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s5"></td><td class="s4"></td><td class="s230" dir="ltr">}</td><td class="s101" dir="ltr"></td><td class="s231" dir="ltr">}</td><td class="s101" dir="ltr"></td><td class="s232" dir="ltr">}</td><td class="s101" dir="ltr"></td><td class="s101" dir="ltr"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s9"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R161" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">162</div></th><td class="s103"></td><td class="s104"></td><td class="s105"></td><td class="s4"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s230" dir="ltr"></td><td class="s101" dir="ltr"></td><td class="s231" dir="ltr"></td><td class="s101" dir="ltr"></td><td class="s232" dir="ltr"></td><td class="s101" dir="ltr"></td><td class="s101" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R162" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">163</div></th><td class="s103"></td><td class="s104"></td><td class="s105"></td><td class="s4"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s233" dir="ltr"></td><td class="s234" dir="ltr"></td><td class="s235" dir="ltr"></td><td class="s234" dir="ltr"></td><td class="s236" dir="ltr"></td><td class="s234" dir="ltr"></td><td class="s234" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td></tr><tr style="height: 20px"><th id="0R163" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">164</div></th><td class="s103"></td><td class="s104"></td><td class="s105"></td><td class="s4"></td><td class="s4"></td><td class="freezebar-cell"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s5"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s233" dir="ltr"></td><td class="s234" dir="ltr"></td><td class="s235" dir="ltr"></td><td class="s234" dir="ltr"></td><td class="s237" dir="ltr"></td><td class="s234" dir="ltr"></td><td class="s234" dir="ltr"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s10"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td><td class="s4"></td></tr></tbody></table></div>