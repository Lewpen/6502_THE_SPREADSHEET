6502 instructions in opcode byte value order with emulation and reversability																																																																														
    https://github.com/Lewpen/6502_THE_SPREADSHEET																																																																														
Machine Code						Explanation		Emulation																					Code Generation Zone									Erased Information								Reverse Instruction				Reverse Emulation																												
Instructions						Reference https://www.masswerk.at/6502/6502_instruction_set.html#ASL		Instruction Setup & Memory Reads				Update Registers					Update Flags							Memory Write (up to 1 byte and 1 word; address and value for each)					Each bright column is an emulator in a language									Trashes (need to be stored per instruction for reverse)								Bytes pushed onto the end of the reverse stack				Uses trashes and current state to undo what the instruction does (for stepping backwards)															Read						Write							
Bytes	Name	Cycles	Args			Description of the instruction		zeroPageWordAddress =	readByteAddress =	readWordAddress =	result (word) =	A =	X =	Y =	SP =	PC =	carry =	zero =	interrupt =	decimal =	break =	overflow =	negative =	writeByteAddress	writeByteValue	writeWordAddress	writeWordValue			// Go		// C		// JS				trashByteAddress	trashWordAddress	trashSR =	trashRegister =	trashPC =	(individual flags)			Bytes	Instruction Name	Arguments		readByteAddress =	readWordAddress =	result =	A =	X =	Y =	SP =	PC =	SR =	writeByteAddress =	writeByte =	writeWordAddress =	writeWord =			Regs			Mem	Flags	Stack	Regs		Mem	Flags	Clear	Set	Stack	
0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	22	23	24	25	26	27	28	55								1	29	30	31	32	33	34	35	36		52	53	54	37	38	39	40	41	42	43	44	45	46	47	48	49	50	51	2	3	4	5	6	7	8	9	10	11	12	13	14	15
																														func Emulate6502( A *uint8, X *unit8, Y *unit8, SP *unit8, PC *uint16, SR *uint8, memory *byte[]) bool {		int Emulate6502( unsigned char *A, unsigned char *X, unsigned char *Y, unsigned char *SP, unsigned int *PC, unsigned char *SR, unsigned char *memory ) {		function Emulate6502( cpu, memory ) {																																												
																														  instruction := memory[PC & 0xFFFF]		  unsigned char instruction = memory[PC & 0xFFFF];		  const A = cpu.A, X = cpu.X, Y = cpu.Y, SP = cpu.SP, PC = cpu.PC, SR = cpu.SR																																												
00 LL	BRK	7	#$LL			Force Break, LL = reason. Pushes PC and SR then jumps to the address stored in the word at 0xFFFE				0xFFFE					SP - 3	readWord			0x1					SP - 2	SR | 0x10	SP - 1	PC + 2			  if instruction == 0x00 { LL := memory[PC + 1]; readWord := memory[(0xFFFE)&0xFFFF] + (memory[((0xFFFE)+1)&0xFFFF]<<8); newSP := SP - 3; newPC := readWord; *SP = newSP; *PC = newPC; carry := SR&1; zero := (SR>>1)&1; interrupt := 0x1;decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = readWord;memory[(SP - 2)&0xFFFF] = SR | 0x10; memory[(SP - 1)&0xFFFF] = (PC + 2)&0xFF; memory[((SP - 1)+1)&0xFFFF] = ((PC + 2)>>8&0xFF; return true }		  if( instruction == 0x00 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int readWord := memory[(0xFFFE)&0xFFFF] + (memory[((0xFFFE)+1)&0xFFFF]<<8); unsigned char newSP = SP - 3; unsigned int newPC = (readWord)&0xFFFF; *SP = newSP; *PC = newPC; unsigned char carry = SR&1; unsigned char zero = (SR>>1)&1; unsigned char interrupt = 0x1;unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = readWord;memory[(SP - 2)&0xFFFF] = SR | 0x10; memory[(SP - 1)&0xFFFF] = (PC + 2)&0xFF; memory[((SP - 1)+1)&0xFFFF] = ((PC + 2)>>8&0xFF; return true; }		  if( instruction == 0x00 ) { const LL = memory[(PC+1)&0xFFFF]; const readWord = memory[(0xFFFE)&0xFFFF] + (memory[((0xFFFE)+1)&0xFFFF]<<8); const newSP = SP - 3; const newPC = (readWord)&0xFFFF; cpu.SP = newSP; cpu.PC = newPC; const carry = SR&1; const zero = (SR>>1)&1; const interrupt = 0x1;const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = readWord;memory[(SP - 2)&0xFFFF] = SR | 0x10; memory[(SP - 1)&0xFFFF] = (PC + 2)&0xFF; memory[((SP - 1)+1)&0xFFFF] = ((PC + 2)>>8&0xFF; return true; }				SP - 2	SP - 1	SR			interrupt			BB LL HH SS 00	UNBRK	$BB, $HHLL, $SS		SP + 1	SP + 2					SP + 3	readWord	SS	SP + 1	BB	SP + 2	HHLL																
01 LL	ORA	6	($LL, X)			Performs bitwise OR between A register and the byte whose address is in the word in zero page at (LL + X), storing result in A		LL + X	zeroPageWord		A | readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x01 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x01 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x01 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 01	UNORA	$SS, $RR					RR					SS							A	X					A							
05 LL	ORA	3	$LL			Performs bitwise OR between A register and the byte in zero LL, storing result in A			LL		A | readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x05 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x05 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x05 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 05	UNORA	$SS, $RR					RR					SS							A			$LL			A							
06 LL	ASL	5	$LL						LL		readByte << 1						readByte >> 7	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x06 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte << 1; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x06 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = readByte << 1; unsigned char carry = readByte >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x06 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = readByte << 1; const carry = readByte >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero, negative			SS 06	UNASL	$SS																														
08	PHP	3													SP - 1									SP	SR | 0x30					  if instruction == 0x08 { newSP := SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&0xFFFF] = SR | 0x30; return true }		  if( instruction == 0x08 ) { unsigned char newSP = SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&0xFFFF] = SR | 0x30; return true; }		  if( instruction == 0x08 ) { const newSP = SP - 1; cpu.SP = newSP; cpu.PC = PC + 1; memory[(SP)&0xFFFF] = SR | 0x30; return true; }				writeByteAddress								BB 08	UNPHP	$BB																														
09 LL	ORA	2	#$LL			Performs bitwise OR between A register and the value LL, storing result in A					A | LL	result						(result | -result) >> 7					result >> 7							  if instruction == 0x09 { LL := memory[PC + 1]; result := A | LL; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x09 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = A | LL; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x09 ) { const LL = memory[(PC+1)&0xFFFF]; const result = A | LL; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 09	UNORA	$SS, $RR																	A						A							
0A	ASL	2	A								A << 1	result					A >> 7	(result | -result) >> 7					result >> 7							  if instruction == 0x0A { result := A << 1; newA := result; *A = newA; carry := A >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x0A ) { unsigned int result = A << 1; unsigned char newA = result; *A = newA; unsigned char carry = A >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x0A ) { const result = A << 1; const newA = result; cpu.A = newA; const carry = A >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			carry, zero, negative			SS 0A	UNASL	$SS				(carry << 7) | (A >> 1)	result												A						A							
0D LL HH	ORA	4	$HHLL			Performs bitwise OR between A register and the byte at address HHLL, storing result in A			HHLL		A | readByte	result											result >> 7							  if instruction == 0x0D { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A | readByte; newA := result; *A = newA; *PC = PC + 3; return true }		  if( instruction == 0x0D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; *PC = PC + 3; return true; }		  if( instruction == 0x0D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR 0D	UNORA	$SS, $RR																	A						A							
0E LL HH	ASL	6	$HHLL						HHLL		readByte << 1						readByte >> 7	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x0E { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte << 1; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x0E ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = readByte << 1; unsigned char carry = readByte >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x0E ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = readByte << 1; const carry = readByte >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero, negative			SS 0E	UNASL	$SS		HHLL		(carry << 7) | (readByte >> 1)							HHLL	result					A						A							
10 LL	BPL	2**	$LL													PC + 2 + (LL & (negative-1))														  if instruction == 0x10 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (negative-1)); *PC = newPC; *PC = PC + 2 + (LL & (negative-1));return true }		  if( instruction == 0x10 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int newPC = (PC + 2 + (LL & (negative-1)))&0xFFFF; *PC = newPC; *PC = PC + 2 + (LL & (negative-1));return true; }		  if( instruction == 0x10 ) { const LL = memory[(PC+1)&0xFFFF]; const newPC = (PC + 2 + (LL & (negative-1)))&0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL & (negative-1));return true; }												10	UNBPL																															
11 LL	ORA	5*	($LL), Y					LL	zeroPageWord + Y		A | readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x11 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x11 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord + Y)&0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x11 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord + Y)&0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 11	UNORA	$SS, $RR																	A	Y					A							
15 LL	ORA	4	$LL, X						(LL + X) & 0xFF		A | readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x15 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x15 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x15 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 15	UNORA	$SS, $RR																	A	X					A							
16 LL	ASL	6	($LL, X)					LL + X	zeroPageWord		readByte << 1						readByte >> 7	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x16 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := readByte << 1; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x16 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = readByte << 1; unsigned char carry = readByte >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x16 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = readByte << 1; const carry = readByte >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero, negative			SS 16	UNASL	$SS																	A	X					A							
18	CLC	2															0x0													  if instruction == 0x18 { carry := 0x0;zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x18 ) { unsigned char carry = 0x0;unsigned char zero = (SR>>1)&1; unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x18 ) { const carry = 0x0;const zero = (SR>>1)&1; const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			carry			SS 18	UNCLC																															
19 LL HH	ORA	4*	$HHLL, Y						HHLL + Y		A | readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x19 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x19 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + Y)&0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x19 ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + Y)&0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR 19	UNORA	$SS, $RR																	A	Y					A							
1D LL HH	ORA	4*	$HHLL, X						HHLL + X		A | readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x1D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A | readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x1D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = A | readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x1D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = A | readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR 1D	UNORA	$SS, $RR																														
1E LL HH	ASL	7	$HHLL, X						HHLL + X		readByte << 1						readByte >> 7	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x1E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := readByte << 1; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x1E ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = readByte << 1; unsigned char carry = readByte >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x1E ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = readByte << 1; const carry = readByte >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero, negative			SS 1E	UNASL	$SS																														
20 LL HH	JSR	6	$HHLL												SP - 2	HHLL										SP - 1	PC + 3			  if instruction == 0x20 { LL := memory[PC + 1]; newSP := SP - 2; newPC := HHLL; *SP = newSP; *PC = newPC; *PC = HHLL;memory[(SP - 1)&0xFFFF] = (PC + 3)&0xFF; memory[((SP - 1)+1)&0xFFFF] = ((PC + 3)>>8&0xFF; return true }		  if( instruction == 0x20 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char newSP = SP - 2; unsigned int newPC = (HHLL)&0xFFFF; *SP = newSP; *PC = newPC; *PC = HHLL;memory[(SP - 1)&0xFFFF] = (PC + 3)&0xFF; memory[((SP - 1)+1)&0xFFFF] = ((PC + 3)>>8&0xFF; return true; }		  if( instruction == 0x20 ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const newSP = SP - 2; const newPC = (HHLL)&0xFFFF; cpu.SP = newSP; cpu.PC = newPC; *PC = HHLL;memory[(SP - 1)&0xFFFF] = (PC + 3)&0xFF; memory[((SP - 1)+1)&0xFFFF] = ((PC + 3)>>8&0xFF; return true; }								PC				PP QQ 20	UNJSR	$QQPP																														
21 LL	AND	6	($LL, X)					LL + X	zeroPageWord		A & readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x21 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x21 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = A & readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x21 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = A & readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 21	UNAND	$SS, $RR																	A	X					A			NZ....				
24 LL	BIT	3	$LL						LL		A & readByte							(result | -result) >> 7				readByte >> 6	readByte >> 7							  if instruction == 0x24 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A & readByte; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := readByte >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x24 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = A & readByte; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = readByte >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x24 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = A & readByte; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = readByte >> 6;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			negative, zero, overflow			SS 24	UNBIT	$SS																	A			$LL						NZ...V				
25 LL	AND	3	$LL						LL		A & readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x25 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x25 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = A & readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x25 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = A & readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 25	UNAND	$SS, $RR																	A			$LL										
26 LL	ROL	5	$LL						LL		(readByte << 1) + carry						readByte >> 7	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x26 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := (readByte << 1) + carry; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x26 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = (readByte << 1) + carry; unsigned char carry = readByte >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x26 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = (readByte << 1) + carry; const carry = readByte >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			zero, negative			SS 26	UNROL	$SS																														
28	PLP	4							SP + 1		readByte				SP + 1		result	(result | -result) >> 7	result >> 2	result >> 3	0	result >> 6	result >> 7							  if instruction == 0x28 { readByte := memory[(SP + 1)&0xFFFF]; result := readByte; newSP := SP + 1; *SP = newSP; carry := result;zero := (result | -result) >> 7;interrupt := result >> 2;decimal := result >> 3;overflow := 0;negative := result >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x28 ) { unsigned char readByte = memory[(SP + 1)&0xFFFF]; unsigned int result = readByte; unsigned char newSP = SP + 1; *SP = newSP; unsigned char carry = result;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = result >> 2;unsigned char decimal = result >> 3;unsigned char overflow = 0;unsigned char negative = result >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x28 ) { const readByte = memory[(SP + 1)&0xFFFF]; const result = readByte; const newSP = SP + 1; cpu.SP = newSP; const carry = result;const zero = (result | -result) >> 7;const interrupt = result >> 2;const decimal = result >> 3;const overflow = 0;const negative = result >> 6;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			*			SS 28	UNPLP	$SS																														
29 LL	AND	2	#$LL								A & LL	result						(result | -result) >> 7					result >> 7							  if instruction == 0x29 { LL := memory[PC + 1]; result := A & LL; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x29 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = A & LL; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x29 ) { const LL = memory[(PC+1)&0xFFFF]; const result = A & LL; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 29	UNAND	$SS, $RR				trash_A	result					trash_carry																				
2A	ROL	2	A								(A << 1) + carry	result					A >> 7	(result | -result) >> 7					result >> 7							  if instruction == 0x2A { result := (A << 1) + carry; newA := result; *A = newA; carry := A >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x2A ) { unsigned int result = (A << 1) + carry; unsigned char newA = result; *A = newA; unsigned char carry = A >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x2A ) { const result = (A << 1) + carry; const newA = result; cpu.A = newA; const carry = A >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			zero, negative			SS 2A	UNROL	$SS																														
2C LL HH	BIT	4	$HHLL						HHLL		A & readByte							(result | -result) >> 7				readByte >> 6	readByte >> 7							  if instruction == 0x2C { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A & readByte; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := readByte >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x2C ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = A & readByte; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = readByte >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x2C ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = A & readByte; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = readByte >> 6;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			negative, zero, overflow			SS 2C	UNBIT	$SS																														
2D LL HH	AND	4	$HHLL						HHLL		A & readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x2D { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x2D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = A & readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x2D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = A & readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR 2D	UNAND	$SS, $RR																														
2E LL HH	ROL	6	$HHLL						HHLL		(readByte << 1) + carry						readByte >> 7	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x2E { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := (readByte << 1) + carry; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x2E ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = (readByte << 1) + carry; unsigned char carry = readByte >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x2E ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = (readByte << 1) + carry; const carry = readByte >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			zero, negative			SS 2E	UNROL	$SS																														
30 LL	BMI	2**	$LL													PC + 2 + (LL & (-negative))														  if instruction == 0x30 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (-negative)); *PC = newPC; *PC = PC + 2 + (LL & (-negative));return true }		  if( instruction == 0x30 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int newPC = (PC + 2 + (LL & (-negative)))&0xFFFF; *PC = newPC; *PC = PC + 2 + (LL & (-negative));return true; }		  if( instruction == 0x30 ) { const LL = memory[(PC+1)&0xFFFF]; const newPC = (PC + 2 + (LL & (-negative)))&0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL & (-negative));return true; }								PC				PP QQ 30	UNBMI	$QQPP																														
31 LL	AND	5*	($LL), Y					LL	zeroPageWord + Y		A & readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x31 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x31 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord + Y)&0xFFFF]; unsigned int result = A & readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x31 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord + Y)&0xFFFF]; const result = A & readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 31	UNAND	$SS, $RR																														
35 LL	AND	4	($LL, X)					LL + X	zeroPageWord		A & readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x35 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x35 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = A & readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x35 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = A & readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR 35	UNAND	$SS, $RR																	A	X												
36 LL	ROL	6	$LL, X						(LL + X) & 0xFF		(readByte << 1) + carry						readByte >> 7	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x36 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := (readByte << 1) + carry; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x36 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = (readByte << 1) + carry; unsigned char carry = readByte >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x36 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = (readByte << 1) + carry; const carry = readByte >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			zero, negative			SS 36	UNROL	$SS																														
38	SEC	2															0x1						1							  if instruction == 0x38 { carry := 0x1;zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x38 ) { unsigned char carry = 0x1;unsigned char zero = (SR>>1)&1; unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x38 ) { const carry = 0x1;const zero = (SR>>1)&1; const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			carry			SS 38	UNSEC	$SS																														
39 LL HH	AND	4*	$HHLL, Y						HHLL + Y		A & readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x39 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x39 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + Y)&0xFFFF]; unsigned int result = A & readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x39 ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + Y)&0xFFFF]; const result = A & readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR 39	UNAND	$SS, $RR																														
3D LL HH	AND	4*	$HHLL, X						HHLL + X		A & readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x3D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A & readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x3D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = A & readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x3D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = A & readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR 3D	UNAND	$SS, $RR																														
3E LL HH	ROL	7	$HHLL, X						HHLL + X		(readByte << 1) + carry						readByte >> 7	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x3E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := (readByte << 1) + carry; carry := readByte >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x3E ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = (readByte << 1) + carry; unsigned char carry = readByte >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x3E ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = (readByte << 1) + carry; const carry = readByte >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			zero, negative			SS 3E	UNROL	$SS																														
40	RTI	6							SP + 1	SP + 3					SP + 3	readWord	result	result >> 1	result >> 2	result >> 3	0	result >> 6	result >> 7							  if instruction == 0x40 { readByte := memory[(SP + 1)&0xFFFF]; readWord := memory[(SP + 3)&0xFFFF] + (memory[((SP + 3)+1)&0xFFFF]<<8); newSP := SP + 3; newPC := readWord; *SP = newSP; *PC = newPC; carry := result;zero := result >> 1;interrupt := result >> 2;decimal := result >> 3;overflow := 0;negative := result >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = readWord;return true }		  if( instruction == 0x40 ) { unsigned char readByte = memory[(SP + 1)&0xFFFF]; unsigned int readWord := memory[(SP + 3)&0xFFFF] + (memory[((SP + 3)+1)&0xFFFF]<<8); unsigned char newSP = SP + 3; unsigned int newPC = (readWord)&0xFFFF; *SP = newSP; *PC = newPC; unsigned char carry = result;unsigned char zero = result >> 1;unsigned char interrupt = result >> 2;unsigned char decimal = result >> 3;unsigned char overflow = 0;unsigned char negative = result >> 6;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = readWord;return true; }		  if( instruction == 0x40 ) { const readByte = memory[(SP + 1)&0xFFFF]; const readWord = memory[(SP + 3)&0xFFFF] + (memory[((SP + 3)+1)&0xFFFF]<<8); const newSP = SP + 3; const newPC = (readWord)&0xFFFF; cpu.SP = newSP; cpu.PC = newPC; const carry = result;const zero = result >> 1;const interrupt = result >> 2;const decimal = result >> 3;const overflow = 0;const negative = result >> 6;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = readWord;return true; }						SR		PC				SS PP QQ 40	UNRTI	$SS, $QQPP																														
41 LL	EOR	6	($LL, X)					LL + X	zeroPageWord		A ^ readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x41 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x41 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x41 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			zero, negative			SS 41	UNEOR	$SS																														
45 LL	EOR	3	$LL						LL		A ^ readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x45 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x45 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x45 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			zero, negative			SS 45	UNEOR	$SS																														
46 LL	LSR	5	$LL						LL		readByte >> 1	result					readByte	(result | -result) >> 7					0x0	readByteAddress	result					  if instruction == 0x46 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte >> 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x46 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = readByte >> 1; unsigned char newA = result; *A = newA; unsigned char carry = readByte;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x46 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = readByte >> 1; const newA = result; cpu.A = newA; const carry = readByte;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero, negative			SS 46	UNLSR	$SS																														
48	PHA	3													SP - 1									SP	A					  if instruction == 0x48 { newSP := SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&0xFFFF] = A; return true }		  if( instruction == 0x48 ) { unsigned char newSP = SP - 1; *SP = newSP; *PC = PC + 1; memory[(SP)&0xFFFF] = A; return true; }		  if( instruction == 0x48 ) { const newSP = SP - 1; cpu.SP = newSP; cpu.PC = PC + 1; memory[(SP)&0xFFFF] = A; return true; }				writeByteAddress								BB 48	UNPHA	$BB																														
49 LL	EOR	2	#$LL								A ^ LL	result						(result | -result) >> 7					result >> 7							  if instruction == 0x49 { LL := memory[PC + 1]; result := A ^ LL; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x49 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = A ^ LL; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x49 ) { const LL = memory[(PC+1)&0xFFFF]; const result = A ^ LL; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			zero, negative			SS 49	UNEOR	$SS																														
4A	LSR	2	A								A >> 1	result					A	(result | -result) >> 7					0x0							  if instruction == 0x4A { result := A >> 1; newA := result; *A = newA; carry := A;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x4A ) { unsigned int result = A >> 1; unsigned char newA = result; *A = newA; unsigned char carry = A;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x4A ) { const result = A >> 1; const newA = result; cpu.A = newA; const carry = A;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			carry, zero, negative			SS 4A	UNLSR	$SS																														
4C	JMP	5	$HHLL													HHLL														  if instruction == 0x4C { newPC := HHLL; *PC = newPC; *PC = HHLL;return true }		  if( instruction == 0x4C ) { unsigned int newPC = (HHLL)&0xFFFF; *PC = newPC; *PC = HHLL;return true; }		  if( instruction == 0x4C ) { const newPC = (HHLL)&0xFFFF; cpu.PC = newPC; *PC = HHLL;return true; }								PC				PP QQ 4C	UNJMP	$QQPP																														
4D LL HH	EOR	4	$HHLL						HHLL		A ^ readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x4D { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x4D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x4D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			zero, negative			SS 4D	UNEOR	$SS																														
4E LL HH	LSR	6	$HHLL						HHLL		readByte >> 1	result					readByte	(result | -result) >> 7					0x0	readByteAddress	result					  if instruction == 0x4E { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte >> 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x4E ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = readByte >> 1; unsigned char newA = result; *A = newA; unsigned char carry = readByte;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x4E ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = readByte >> 1; const newA = result; cpu.A = newA; const carry = readByte;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero, negative			SS 4E	UNLSR	$SS																														
50 LL	BVC	2**	#$LL			Branch if overflow clear										PC + 2 + (LL & (overflow-1))														  if instruction == 0x50 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (overflow-1)); *PC = newPC; *PC = PC + 2 + (LL & (overflow-1));return true }		  if( instruction == 0x50 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int newPC = (PC + 2 + (LL & (overflow-1)))&0xFFFF; *PC = newPC; *PC = PC + 2 + (LL & (overflow-1));return true; }		  if( instruction == 0x50 ) { const LL = memory[(PC+1)&0xFFFF]; const newPC = (PC + 2 + (LL & (overflow-1)))&0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL & (overflow-1));return true; }								PC				PP QQ 50	UNBVC	$QQPP					PC																									
51 LL	EOR	5*	($LL), Y					LL	zeroPageWord + Y		A ^ readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x51 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x51 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord + Y)&0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x51 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord + Y)&0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			zero, negative			SS 51	UNEOR	$SS																														
55 LL	EOR	4	$LL, X						(LL + X) & 0xFF		A ^ readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x55 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x55 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x55 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			zero, negative			SS 55	UNEOR	$SS																														
56 LL	LSR	6	$LL, X						(LL + X) & 0xFF		readByte >> 1	result					readByte	(result | -result) >> 7					0x0	readByteAddress	result					  if instruction == 0x56 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte >> 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x56 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = readByte >> 1; unsigned char newA = result; *A = newA; unsigned char carry = readByte;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x56 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = readByte >> 1; const newA = result; cpu.A = newA; const carry = readByte;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero, negative			SS 56	UNLSR	$SS																														
58	CLI	2																	0x0											  if instruction == 0x58 { carry := SR&1; zero := (SR>>1)&1; interrupt := 0x0;decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x58 ) { unsigned char carry = SR&1; unsigned char zero = (SR>>1)&1; unsigned char interrupt = 0x0;unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x58 ) { const carry = SR&1; const zero = (SR>>1)&1; const interrupt = 0x0;const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			interrupt			SS 58	UNCLI	$SS																														
59 LL HH	EOR	4*	$HHLL, Y						HHLL + Y		A ^ readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x59 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x59 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + Y)&0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x59 ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + Y)&0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			zero, negative			SS 59	UNEOR	$SS																														
5D LL HH	EOR	4*	$HHLL, X						HHLL + X		A ^ readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x5D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A ^ readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x5D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = A ^ readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x5D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = A ^ readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			zero, negative			SS 5D	UNEOR	$SS																														
5E	LSR	7	$HHLL, X						HHLL + X		readByte >> 1	result					readByte	(result | -result) >> 7					0x0	readByteAddress	result					  if instruction == 0x5E { readByte := memory[(HHLL + X)&0xFFFF]; result := readByte >> 1; newA := result; *A = newA; carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x5E ) { unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = readByte >> 1; unsigned char newA = result; *A = newA; unsigned char carry = readByte;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x5E ) { const readByte = memory[(HHLL + X)&0xFFFF]; const result = readByte >> 1; const newA = result; cpu.A = newA; const carry = readByte;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero, negative			SS 5E	UNLSR	$SS																														
60	RTS	6								SP + 1					SP + 2	readWord														  if instruction == 0x60 { readWord := memory[(SP + 1)&0xFFFF] + (memory[((SP + 1)+1)&0xFFFF]<<8); newSP := SP + 2; newPC := readWord; *SP = newSP; *PC = newPC; *PC = readWord;return true }		  if( instruction == 0x60 ) { unsigned int readWord := memory[(SP + 1)&0xFFFF] + (memory[((SP + 1)+1)&0xFFFF]<<8); unsigned char newSP = SP + 2; unsigned int newPC = (readWord)&0xFFFF; *SP = newSP; *PC = newPC; *PC = readWord;return true; }		  if( instruction == 0x60 ) { const readWord = memory[(SP + 1)&0xFFFF] + (memory[((SP + 1)+1)&0xFFFF]<<8); const newSP = SP + 2; const newPC = (readWord)&0xFFFF; cpu.SP = newSP; cpu.PC = newPC; *PC = readWord;return true; }								PC	PC			PP QQ 60	UNRTS	$QQPP																														
61 LL	ADC	6	($LL, X)					LL + X	zeroPageWord		A + readByte + carry	result					(A - result) >> 7	(result | -result) >> 7				((A ^ result) & (readByte ^ result)) >> 7	result >> 7							  if instruction == 0x61 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x61 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x61 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ((A ^ result) & (readByte ^ result)) >> 7;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, overflow			SS 61	UNADC	$SS																	A	X		$LL	..C...		A			NZC..V				
65 LL	ADC	3	$LL						LL		A + readByte + carry	result					(A - result) >> 7	(result | -result) >> 7				((A ^ result) & (readByte ^ result)) >> 7	result >> 7							  if instruction == 0x65 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x65 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x65 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ((A ^ result) & (readByte ^ result)) >> 7;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, overflow			SS 65	UNADC	$SS																	A			$LL	..C...		A			NZC..V				
66 LL	ROR	5	$LL						LL		(readByte >> 1) + (carry << 7)						readByte	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x66 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := (readByte >> 1) + (carry << 7); carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x66 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = (readByte >> 1) + (carry << 7); unsigned char carry = readByte;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x66 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = (readByte >> 1) + (carry << 7); const carry = readByte;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			zero, negative			SS 66	UNROR	$SS																														
68	PLA	4							SP + 1		readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0x68 { readByte := memory[(SP + 1)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x68 ) { unsigned char readByte = memory[(SP + 1)&0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x68 ) { const readByte = memory[(SP + 1)&0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	A		A, zero, negative			SS RR 68	UNPLA	$SS																														
69 LL	ADC	2	#$LL								A + LL + carry	result					(A - result) >> 7	(result | -result) >> 7				((A ^ result) & (readByte ^ result)) >> 7	result >> 7							  if instruction == 0x69 { LL := memory[PC + 1]; result := A + LL + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x69 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = A + LL + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x69 ) { const LL = memory[(PC+1)&0xFFFF]; const result = A + LL + carry; const newA = result; cpu.A = newA; const carry = (A - result) >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ((A ^ result) & (readByte ^ result)) >> 7;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, overflow			SS 69	UNADC	$SS																	A				..C...		A			NZC..V				
6A	ROR	2	A								(A >> 1) + (carry << 7)	result					A	(result | -result) >> 7					result >> 7							  if instruction == 0x6A { result := (A >> 1) + (carry << 7); newA := result; *A = newA; carry := A;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x6A ) { unsigned int result = (A >> 1) + (carry << 7); unsigned char newA = result; *A = newA; unsigned char carry = A;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x6A ) { const result = (A >> 1) + (carry << 7); const newA = result; cpu.A = newA; const carry = A;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			zero, negative			SS 6A	UNROR	$SS																														
6C	JMP	3	($HHLL)							HHLL						readWord														  if instruction == 0x6C { readWord := memory[(HHLL)&0xFFFF] + (memory[((HHLL)+1)&0xFFFF]<<8); newPC := readWord; *PC = newPC; *PC = readWord;return true }		  if( instruction == 0x6C ) { unsigned int readWord := memory[(HHLL)&0xFFFF] + (memory[((HHLL)+1)&0xFFFF]<<8); unsigned int newPC = (readWord)&0xFFFF; *PC = newPC; *PC = readWord;return true; }		  if( instruction == 0x6C ) { const readWord = memory[(HHLL)&0xFFFF] + (memory[((HHLL)+1)&0xFFFF]<<8); const newPC = (readWord)&0xFFFF; cpu.PC = newPC; *PC = readWord;return true; }								PC	PC			PP QQ 6C	UNJMP	$QQPP																														
6D LL HH	ADC	4	$HHLL						HHLL		A + readByte + carry	result					(A - result) >> 7	(result | -result) >> 7				((A ^ result) & (readByte ^ result)) >> 7	result >> 7							  if instruction == 0x6D { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x6D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x6D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ((A ^ result) & (readByte ^ result)) >> 7;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			carry, zero, overflow			SS 6D	UNADC	$SS																	A			$HHLL	..C...		A			NZC..V				
6E LL HH	ROR	6	$HHLL						HHLL		(readByte >> 1) + (carry << 7)						readByte	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x6E { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := (readByte >> 1) + (carry << 7); carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x6E ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = (readByte >> 1) + (carry << 7); unsigned char carry = readByte;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x6E ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = (readByte >> 1) + (carry << 7); const carry = readByte;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			zero, negative			SS 6E	UNROR	$SS																														
70 LL	BVS	2**	$LL													PC + 2 + (LL & (-overflow))														  if instruction == 0x70 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (-overflow)); *PC = newPC; *PC = PC + 2 + (LL & (-overflow));return true }		  if( instruction == 0x70 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int newPC = (PC + 2 + (LL & (-overflow)))&0xFFFF; *PC = newPC; *PC = PC + 2 + (LL & (-overflow));return true; }		  if( instruction == 0x70 ) { const LL = memory[(PC+1)&0xFFFF]; const newPC = (PC + 2 + (LL & (-overflow)))&0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL & (-overflow));return true; }								PC				PP QQ 70	UNBVS	$QQPP																														
71 LL	ADC	5*	($LL),Y					LL	zeroPageWord + Y		A + readByte + carry	result					(A - result) >> 7	(result | -result) >> 7				((A ^ result) & (readByte ^ result)) >> 7	result >> 7							  if instruction == 0x71 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x71 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord + Y)&0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x71 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord + Y)&0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ((A ^ result) & (readByte ^ result)) >> 7;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, overflow			SS 71	UNADC	$SS																	A	Y			..C...		A			NZC..V				
75 LL	ADC	4	$LL, X						(LL + X) & 0xFF		A + readByte + carry	result					(A - result) >> 7	(result | -result) >> 7				((A ^ result) & (readByte ^ result)) >> 7	result >> 7							  if instruction == 0x75 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0x75 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0x75 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ((A ^ result) & (readByte ^ result)) >> 7;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, overflow			SS 75	UNADC	$SS																	A	X			..C...		A			NZC..V				
76 LL	ROR	6	$LL, X						(LL + X) & 0xFF		(readByte >> 1) + (carry << 7)						readByte	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x76 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := (readByte >> 1) + (carry << 7); carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x76 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = (readByte >> 1) + (carry << 7); unsigned char carry = readByte;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x76 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = (readByte >> 1) + (carry << 7); const carry = readByte;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			zero, negative			SS 76	UNROR	$SS																														
78	SEI	2																	0x1											  if instruction == 0x78 { carry := SR&1; zero := (SR>>1)&1; interrupt := 0x1;decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x78 ) { unsigned char carry = SR&1; unsigned char zero = (SR>>1)&1; unsigned char interrupt = 0x1;unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x78 ) { const carry = SR&1; const zero = (SR>>1)&1; const interrupt = 0x1;const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			interrupt			SS 78	UNSEI	$SS																														
79 LL HH	ADC	4*	$HHLL, Y						HHLL + Y		A + readByte + carry	result					(A - result) >> 7	(result | -result) >> 7				((A ^ result) & (readByte ^ result)) >> 7	result >> 7							  if instruction == 0x79 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x79 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + Y)&0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x79 ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + Y)&0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ((A ^ result) & (readByte ^ result)) >> 7;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			carry, zero, overflow			SS 79	UNADC	$SS																	A	Y			..C...		A			NZC..V				
7D LL HH	ADC	4*	$HHLL, X						HHLL + X		A + readByte + carry	result					(A - result) >> 7	(result | -result) >> 7				((A ^ result) & (readByte ^ result)) >> 7	result >> 7							  if instruction == 0x7D { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A + readByte + carry; newA := result; *A = newA; carry := (A - result) >> 7;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0x7D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = A + readByte + carry; unsigned char newA = result; *A = newA; unsigned char carry = (A - result) >> 7;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ((A ^ result) & (readByte ^ result)) >> 7;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0x7D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = A + readByte + carry; const newA = result; cpu.A = newA; const carry = (A - result) >> 7;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ((A ^ result) & (readByte ^ result)) >> 7;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			carry, zero, overflow			SS 7D	UNADC	$SS																	A	X			..C...		A			NZC..V				
7E LL HH	ROR	7	$HHLL, X						HHLL + X		(readByte >> 1) + (carry << 7)						readByte	(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0x7E { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := (readByte >> 1) + (carry << 7); carry := readByte;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0x7E ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = (readByte >> 1) + (carry << 7); unsigned char carry = readByte;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0x7E ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = (readByte >> 1) + (carry << 7); const carry = readByte;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			zero, negative			SS 7E	UNROR	$SS																														
81 LL	STA	6	($LL, X)					LL + X																zeroPageWord	A					  if instruction == 0x81 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord)&0xFFFF] = A; return true }		  if( instruction == 0x81 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord)&0xFFFF] = A; return true; }		  if( instruction == 0x81 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); cpu.PC = PC + 2; memory[(zeroPageWord)&0xFFFF] = A; return true; }				writeByteAddress			A		A			BB RR 81	UNSTA	$BB, $RR																														
84 LL	STY	3	$LL																					LL	Y					  if instruction == 0x84 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&0xFFFF] = Y; return true }		  if( instruction == 0x84 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; *PC = PC + 2; memory[(LL)&0xFFFF] = Y; return true; }		  if( instruction == 0x84 ) { const LL = memory[(PC+1)&0xFFFF]; cpu.PC = PC + 2; memory[(LL)&0xFFFF] = Y; return true; }				writeByteAddress			A		A			BB RR 84	UNSTY	$BB, $RR																														
85 LL	STA	3	$LL																					LL	A					  if instruction == 0x85 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&0xFFFF] = A; return true }		  if( instruction == 0x85 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; *PC = PC + 2; memory[(LL)&0xFFFF] = A; return true; }		  if( instruction == 0x85 ) { const LL = memory[(PC+1)&0xFFFF]; cpu.PC = PC + 2; memory[(LL)&0xFFFF] = A; return true; }				writeByteAddress			A		A			BB RR 85	UNSTA	$BB, $RR																														
86 LL	STX	3	$LL																					LL	X					  if instruction == 0x86 { LL := memory[PC + 1]; *PC = PC + 2; memory[(LL)&0xFFFF] = X; return true }		  if( instruction == 0x86 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; *PC = PC + 2; memory[(LL)&0xFFFF] = X; return true; }		  if( instruction == 0x86 ) { const LL = memory[(PC+1)&0xFFFF]; cpu.PC = PC + 2; memory[(LL)&0xFFFF] = X; return true; }				writeByteAddress			A		A			BB RR 86	UNSTX	$BB, $RR																														
88	DEY	2									Y - 1			result				(result | -result) >> 7					result >> 7							  if instruction == 0x88 { result := Y - 1; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x88 ) { unsigned int result = Y - 1; unsigned char newY = result; *Y = newY; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x88 ) { const result = Y - 1; const newY = result; cpu.Y = newY; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			negative, zero			SS 88	UNDEY	$SS																														
8A	TXA	2									X	result						(result | -result) >> 7					result >> 7							  if instruction == 0x8A { result := X; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x8A ) { unsigned int result = X; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x8A ) { const result = X; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	A		zero, negative			SS RR 8A	UNTXA	$SS, $RR																														
8C LL HH	STY	4	$HHLL																					HHLL	Y					  if instruction == 0x8C { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&0xFFFF] = Y; return true }		  if( instruction == 0x8C ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); *PC = PC + 3; memory[(HHLL)&0xFFFF] = Y; return true; }		  if( instruction == 0x8C ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); cpu.PC = PC + 3; memory[(HHLL)&0xFFFF] = Y; return true; }				writeByteAddress								BB 8C	UNSTY	$BB																														
8D LL HH	STA	4	$HHLL																					HHLL	A					  if instruction == 0x8D { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&0xFFFF] = A; return true }		  if( instruction == 0x8D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); *PC = PC + 3; memory[(HHLL)&0xFFFF] = A; return true; }		  if( instruction == 0x8D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); cpu.PC = PC + 3; memory[(HHLL)&0xFFFF] = A; return true; }				writeByteAddress								BB 8D	UNSTA	$BB																														
8E LL HH	STX	4	$HHLL																					HHLL	X					  if instruction == 0x8E { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL)&0xFFFF] = X; return true }		  if( instruction == 0x8E ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); *PC = PC + 3; memory[(HHLL)&0xFFFF] = X; return true; }		  if( instruction == 0x8E ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); cpu.PC = PC + 3; memory[(HHLL)&0xFFFF] = X; return true; }				writeByteAddress								BB 8E	UNSTX	$BB																														
90 LL	BCC	2**	$LL			Branch if carry flag is clear to the relative address specified by LL. The branch destination is relative to the start byte of the next instruction.										PC + 2 + (LL & (carry-1))														  if instruction == 0x90 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (carry-1)); *PC = newPC; *PC = PC + 2 + (LL & (carry-1));return true }		  if( instruction == 0x90 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int newPC = (PC + 2 + (LL & (carry-1)))&0xFFFF; *PC = newPC; *PC = PC + 2 + (LL & (carry-1));return true; }		  if( instruction == 0x90 ) { const LL = memory[(PC+1)&0xFFFF]; const newPC = (PC + 2 + (LL & (carry-1)))&0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL & (carry-1));return true; }								PC				PP QQ 90	UNBCC	$QQPP																														
91 LL	STA	6	($LL), Y					LL																zeroPageWord + Y	A					  if instruction == 0x91 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord + Y)&0xFFFF] = A; return true }		  if( instruction == 0x91 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord + Y)&0xFFFF] = A; return true; }		  if( instruction == 0x91 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); cpu.PC = PC + 2; memory[(zeroPageWord + Y)&0xFFFF] = A; return true; }				writeByteAddress								BB 91	UNSTA	$BB																														
94 LL	STY	4	$LL, X																					(LL + X) & 0xFF	Y					  if instruction == 0x94 { LL := memory[PC + 1]; *PC = PC + 2; memory[((LL + X) & 0xFF)&0xFFFF] = Y; return true }		  if( instruction == 0x94 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; *PC = PC + 2; memory[((LL + X) & 0xFF)&0xFFFF] = Y; return true; }		  if( instruction == 0x94 ) { const LL = memory[(PC+1)&0xFFFF]; cpu.PC = PC + 2; memory[((LL + X) & 0xFF)&0xFFFF] = Y; return true; }				writeByteAddress								BB 94	UNSTY	$BB																														
95 LL	STA	4	$LL, X																					(LL + X) & 0xFF	A					  if instruction == 0x95 { LL := memory[PC + 1]; *PC = PC + 2; memory[((LL + X) & 0xFF)&0xFFFF] = A; return true }		  if( instruction == 0x95 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; *PC = PC + 2; memory[((LL + X) & 0xFF)&0xFFFF] = A; return true; }		  if( instruction == 0x95 ) { const LL = memory[(PC+1)&0xFFFF]; cpu.PC = PC + 2; memory[((LL + X) & 0xFF)&0xFFFF] = A; return true; }				writeByteAddress								BB 95	UNSTA	$BB																														
96 LL	STX	4	$LL, Y					LL																zeroPageWord + Y	X					  if instruction == 0x96 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord + Y)&0xFFFF] = X; return true }		  if( instruction == 0x96 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); *PC = PC + 2; memory[(zeroPageWord + Y)&0xFFFF] = X; return true; }		  if( instruction == 0x96 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); cpu.PC = PC + 2; memory[(zeroPageWord + Y)&0xFFFF] = X; return true; }				writeByteAddress								BB 96	UNSTX	$BB																														
98	TYA	2									Y	result						(result | -result) >> 7					result >> 7							  if instruction == 0x98 { result := Y; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0x98 ) { unsigned int result = Y; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0x98 ) { const result = Y; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	A		zero, negative			SS RR 98	UNTYA	$SS, $RR																														
99 LL HH	STA	5	$HHLL, Y																					HHLL + Y	A					  if instruction == 0x99 { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL + Y)&0xFFFF] = A; return true }		  if( instruction == 0x99 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); *PC = PC + 3; memory[(HHLL + Y)&0xFFFF] = A; return true; }		  if( instruction == 0x99 ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); cpu.PC = PC + 3; memory[(HHLL + Y)&0xFFFF] = A; return true; }				writeByteAddress								BB 99	UNSTA	$BB																														
9A	TXS	2									X				result															  if instruction == 0x9A { result := X; newSP := result; *SP = newSP; *PC = PC + 1; return true }		  if( instruction == 0x9A ) { unsigned int result = X; unsigned char newSP = result; *SP = newSP; *PC = PC + 1; return true; }		  if( instruction == 0x9A ) { const result = X; const newSP = result; cpu.SP = newSP; cpu.PC = PC + 1; return true; }							SP					RR 9A	UNTXS	$RR																														
9D LL HH	STA	5	$HHLL, X																					HHLL + X	A					  if instruction == 0x9D { LL := memory[PC + 1]; *PC = PC + 3; memory[(HHLL + X)&0xFFFF] = A; return true }		  if( instruction == 0x9D ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); *PC = PC + 3; memory[(HHLL + X)&0xFFFF] = A; return true; }		  if( instruction == 0x9D ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); cpu.PC = PC + 3; memory[(HHLL + X)&0xFFFF] = A; return true; }				writeByteAddress								BB 9D	UNSTA	$BB																														
A0 LL	LDY	2	#$LL								LL			result				(result | -result) >> 7					result >> 7							  if instruction == 0xA0 { LL := memory[PC + 1]; result := LL; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xA0 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = LL; unsigned char newY = result; *Y = newY; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xA0 ) { const LL = memory[(PC+1)&0xFFFF]; const result = LL; const newY = result; cpu.Y = newY; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	Y		zero, negative			SS RR A0	UNLDY	$SS, $RR																														
A1	LDA	6	($LL, X)					LL + X	zeroPageWord		readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0xA1 { zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xA1 ) { unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xA1 ) { const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	A		zero, negative			SS RR A1	UNLDA	$SS, $RR																														
A2 LL	LDX	2	#$LL								LL		result					(result | -result) >> 7					result >> 7							  if instruction == 0xA2 { LL := memory[PC + 1]; result := LL; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xA2 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = LL; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xA2 ) { const LL = memory[(PC+1)&0xFFFF]; const result = LL; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	X		zero, negative			SS RR A2	UNLDX	$SS, $RR																														
A4 LL	LDY	3	$LL						LL		readByte			result				(result | -result) >> 7					result >> 7							  if instruction == 0xA4 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xA4 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = readByte; unsigned char newY = result; *Y = newY; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xA4 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = readByte; const newY = result; cpu.Y = newY; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	Y		zero, negative			SS RR A4	UNLDY	$SS, $RR																														
A5 LL	LDA	3	$LL						LL		readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0xA5 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xA5 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xA5 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR A5	UNLDA	$SS, $RR																														
A6 LL	LDX	3	$LL						LL		readByte		result					(result | -result) >> 7					result >> 7							  if instruction == 0xA6 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xA6 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = readByte; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xA6 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = readByte; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	X		zero, negative			SS RR A6	UNLDX	$SS, $RR																														
A8	TAY	2									A			result				(result | -result) >> 7					result >> 7							  if instruction == 0xA8 { result := A; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xA8 ) { unsigned int result = A; unsigned char newY = result; *Y = newY; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xA8 ) { const result = A; const newY = result; cpu.Y = newY; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	Y		zero, negative			SS RR A8	UNTAY	$SS, $RR																														
A9 LL	LDA	2	#$LL								LL	result						(result | -result) >> 7					result >> 7							  if instruction == 0xA9 { LL := memory[PC + 1]; result := LL; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xA9 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = LL; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xA9 ) { const LL = memory[(PC+1)&0xFFFF]; const result = LL; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR A9	UNLDA	$SS, $RR																														
AA	TAX	2									A		result					(result | -result) >> 7					result >> 7							  if instruction == 0xAA { result := A; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xAA ) { unsigned int result = A; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xAA ) { const result = A; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	X		zero, negative			SS RR AA	UNTAX	$SS, $RR																														
AC LL HH	LDY	4	$HHLL						HHLL		readByte			result				(result | -result) >> 7					result >> 7							  if instruction == 0xAC { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xAC ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = readByte; unsigned char newY = result; *Y = newY; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xAC ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = readByte; const newY = result; cpu.Y = newY; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	Y		zero, negative			SS RR AC	UNLDY	$SS, $RR																														
AD LL HH	LDA	4	$HHLL						HHLL		readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0xAD { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xAD ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xAD ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR AD	UNLDA	$SS, $RR																														
AE LL HH	LDX	4	$HHLL						HHLL		readByte		result					(result | -result) >> 7					result >> 7							  if instruction == 0xAE { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xAE ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = readByte; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xAE ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = readByte; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	X		zero, negative			SS RR AE	UNLDX	$SS, $RR																														
B0 LL	BCS	2**	$LL													PC + 2 + (LL & (-carry))														  if instruction == 0xB0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (-carry)); *PC = newPC; *PC = PC + 2 + (LL & (-carry));return true }		  if( instruction == 0xB0 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int newPC = (PC + 2 + (LL & (-carry)))&0xFFFF; *PC = newPC; *PC = PC + 2 + (LL & (-carry));return true; }		  if( instruction == 0xB0 ) { const LL = memory[(PC+1)&0xFFFF]; const newPC = (PC + 2 + (LL & (-carry)))&0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL & (-carry));return true; }								PC				PP QQ B0	UNBCS	$QQPP																														
B1	LDA	5*	($LL), Y					LL	zeroPageWord + Y		readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0xB1 { zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xB1 ) { unsigned int zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord + Y)&0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xB1 ) { const zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord + Y)&0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	A		zero, negative			SS RR B1	UNLDA	$SS, $RR																														
B4	LDY	4	$LL, X						(LL + X) & 0xFF		readByte			result				(result | -result) >> 7					result >> 7							  if instruction == 0xB4 { readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xB4 ) { unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = readByte; unsigned char newY = result; *Y = newY; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xB4 ) { const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = readByte; const newY = result; cpu.Y = newY; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	Y		zero, negative			SS RR B4	UNLDY	$SS, $RR																														
B5 LL	LDA	4	$LL, X						(LL + X) & 0xFF		readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0xB5 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xB5 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xB5 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR	A		zero, negative			SS RR B5	UNLDA	$SS, $RR																														
B6	LDX	4	$LL, Y						(LL + Y) & 0xFF		readByte		result					(result | -result) >> 7					result >> 7							  if instruction == 0xB6 { readByte := memory[((LL + Y) & 0xFF)&0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xB6 ) { unsigned char readByte = memory[((LL + Y) & 0xFF)&0xFFFF]; unsigned int result = readByte; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xB6 ) { const readByte = memory[((LL + Y) & 0xFF)&0xFFFF]; const result = readByte; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	X		zero, negative			SS RR B6	UNLDX	$SS, $RR																														
B8	CLV	2																				0x0								  if instruction == 0xB8 { carry := SR&1; zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := 0x0;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xB8 ) { unsigned char carry = SR&1; unsigned char zero = (SR>>1)&1; unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = 0x0;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xB8 ) { const carry = SR&1; const zero = (SR>>1)&1; const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = 0x0;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			overflow			SS B8	UNCLV	$SS																														
B9 LL HH	LDA	4*	$HHLL, Y						HHLL + Y		readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0xB9 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xB9 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + Y)&0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xB9 ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + Y)&0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR B9	UNLDA	$SS, $RR																														
BA	TSX	2									SP		result					(result | -result) >> 7					result >> 7							  if instruction == 0xBA { result := SP; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xBA ) { unsigned int result = SP; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xBA ) { const result = SP; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	X		zero, negative			SS RR BA	UNTSX	$SS, $RR																														
BC	LDY	4*	$HHLL, X						HHLL + X					result				(result | -result) >> 7					result >> 7							  if instruction == 0xBC { readByte := memory[(HHLL + X)&0xFFFF]; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xBC ) { unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned char newY = result; *Y = newY; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xBC ) { const readByte = memory[(HHLL + X)&0xFFFF]; const newY = result; cpu.Y = newY; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	Y		zero, negative			SS RR BC	UNLDY	$SS, $RR																														
BD LL HH	LDA	4*	$HHLL, X						HHLL + X		readByte	result						(result | -result) >> 7					result >> 7							  if instruction == 0xBD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := readByte; newA := result; *A = newA; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xBD ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = readByte; unsigned char newA = result; *A = newA; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xBD ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = readByte; const newA = result; cpu.A = newA; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR	A		zero, negative			SS RR BD	UNLDA	$SS, $RR																														
BE	LDX	4*	$HHLL, Y						HHLL + Y		readByte		result					(result | -result) >> 7					result >> 7							  if instruction == 0xBE { readByte := memory[(HHLL + Y)&0xFFFF]; result := readByte; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xBE ) { unsigned char readByte = memory[(HHLL + Y)&0xFFFF]; unsigned int result = readByte; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xBE ) { const readByte = memory[(HHLL + Y)&0xFFFF]; const result = readByte; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR	X		zero, negative			SS RR BE	UNLDX	$SS, $RR																														
C0 LL	CPY	2	#$LL								Y - LL						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xC0 { LL := memory[PC + 1]; result := Y - LL; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xC0 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = Y - LL; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xC0 ) { const LL = memory[(PC+1)&0xFFFF]; const result = Y - LL; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS C0	UNCPY	$SS																														
C1 LL	CMP	4	($LL, X)					LL + X	zeroPageWord		A - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xC1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xC1 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xC1 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = A - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS C1	UNCMP	$SS																														
C4 LL	CPY	3	$LL						LL		Y - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xC4 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := Y - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xC4 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = Y - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xC4 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = Y - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS C4	UNCPY	$SS																														
C5 LL	CMP	3	$LL						LL		A - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xC5 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xC5 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xC5 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = A - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS C5	UNCMP	$SS																														
C6 LL	DEC	5	$LL						LL		readByte - 1							(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0xC6 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte - 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0xC6 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = readByte - 1; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0xC6 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = readByte - 1; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			negative, zero			SS C6	UNDEC	$SS																														
C8	INY	2									Y + 1			result				(result | -result) >> 7					result >> 7							  if instruction == 0xC8 { result := Y + 1; newY := result; *Y = newY; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xC8 ) { unsigned int result = Y + 1; unsigned char newY = result; *Y = newY; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xC8 ) { const result = Y + 1; const newY = result; cpu.Y = newY; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			carry, zero			SS C8	UNINY	$SS																														
C9 LL	CMP	2	#$LL								A - LL						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xC9 { LL := memory[PC + 1]; result := A - LL; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xC9 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = A - LL; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xC9 ) { const LL = memory[(PC+1)&0xFFFF]; const result = A - LL; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS C9	UNCMP	$SS																														
CA	DEX	2									X - 1		result					(result | -result) >> 7					result >> 7							  if instruction == 0xCA { result := X - 1; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xCA ) { unsigned int result = X - 1; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xCA ) { const result = X - 1; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			negative, zero			SS CA	UNDEX	$SS																														
CC LL HH	CPY	4	$HHLL						HHLL		Y - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xCC { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := Y - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xCC ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = Y - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xCC ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = Y - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			carry, zero, negative			SS CC	UNCPY	$SS																														
CD LL HH	CMP	4	$HHLL						HHLL		A - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xCD { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xCD ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xCD ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = A - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			carry, zero, negative			SS CD	UNCMP	$SS																														
CE LL HH	DEC	6	$HHLL						HHLL		readByte - 1							(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0xCE { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte - 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0xCE ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = readByte - 1; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0xCE ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = readByte - 1; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			negative, zero			SS CE	UNDEC	$SS																														
D0 LL	BNE	2**	$LL													PC + 2 + (LL & (zero-1))														  if instruction == 0xD0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (zero-1)); *PC = newPC; *PC = PC + 2 + (LL & (zero-1));return true }		  if( instruction == 0xD0 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int newPC = (PC + 2 + (LL & (zero-1)))&0xFFFF; *PC = newPC; *PC = PC + 2 + (LL & (zero-1));return true; }		  if( instruction == 0xD0 ) { const LL = memory[(PC+1)&0xFFFF]; const newPC = (PC + 2 + (LL & (zero-1)))&0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL & (zero-1));return true; }								PC				PP QQ D0	UNBNE	$QQPP																														
D1 LL	CMP	4	($LL), Y					LL	zeroPageWord + YY		A - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xD1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + YY)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xD1 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord + YY)&0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xD1 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL)&0xFF] + (memory[((LL)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord + YY)&0xFFFF]; const result = A - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS D1	UNCMP	$SS																														
D5 LL	CMP	4	$LL, X						(LL + X) & 0xFF		A - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xD5 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xD5 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xD5 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = A - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS D5	UNCMP	$SS																														
D6 LL	DEC	6	$LL, X						(LL + X) & 0xFF		readByte - 1							(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0xD6 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte - 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0xD6 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = readByte - 1; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0xD6 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = readByte - 1; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			negative, zero			SS D6	UNDEC	$SS																														
D8	CLD	2																		0x0										  if instruction == 0xD8 { carry := SR&1; zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := 0x0;overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xD8 ) { unsigned char carry = SR&1; unsigned char zero = (SR>>1)&1; unsigned char interrupt = (SR>>2)&1; unsigned char decimal = 0x0;unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xD8 ) { const carry = SR&1; const zero = (SR>>1)&1; const interrupt = (SR>>2)&1; const decimal = 0x0;const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			decimal			SS D8	UNCLD	$SS																														
D9 LL HH	CMP	4*	$HHLL, Y						HHLL + Y		A - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xD9 { LL := memory[PC + 1]; readByte := memory[(HHLL + Y)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xD9 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + Y)&0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xD9 ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + Y)&0xFFFF]; const result = A - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			carry, zero, negative			SS D9	UNCMP	$SS																														
DD LL HH	CMP	4*	$HHLL, X						HHLL + X		A - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xDD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xDD ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = A - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xDD ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = A - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			carry, zero, negative			SS DD	UNCMP	$SS																														
DE LL HH	DEC	7	$HHLL, X						HHLL + X		readByte - 1							(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0xDE { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := readByte - 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0xDE ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = readByte - 1; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0xDE ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = readByte - 1; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			negative, zero			SS DE	UNDEC	$SS																														
E0 LL	CPX	2	#$LL								X - LL						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xE0 { LL := memory[PC + 1]; result := X - LL; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xE0 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = X - LL; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xE0 ) { const LL = memory[(PC+1)&0xFFFF]; const result = X - LL; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS E0	UNCPX	$SS																														
E1 LL	SBC	6	($LL, X)					LL + X	zeroPageWord		A - readByte - (carry^1)	result					???	(result | -result) >> 7				???	result >> 7							  if instruction == 0xE1 { LL := memory[PC + 1]; zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xE1 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord)&0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xE1 ) { const LL = memory[(PC+1)&0xFFFF]; const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord)&0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ???;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }									???			E1	UNSBC																															
E4 LL	CPX	3	$LL						LL		X - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xE4 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := X - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xE4 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = X - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xE4 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = X - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			carry, zero, negative			SS E4	UNCPX	$SS																														
E5 LL	SBC	3	$LL						LL		A - readByte - (carry^1)	result					???	(result | -result) >> 7				???	result >> 7							  if instruction == 0xE5 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xE5 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xE5 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ???;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }									???			E5	UNSBC																															
E6 LL	INC	5	$LL						LL		readByte + 1							(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0xE6 { LL := memory[PC + 1]; readByte := memory[(LL)&0xFFFF]; result := readByte + 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0xE6 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[(LL)&0xFFFF]; unsigned int result = readByte + 1; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0xE6 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[(LL)&0xFFFF]; const result = readByte + 1; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero			SS E6	UNINC	$SS																														
E8	INX	2									X + 1		result					(result | -result) >> 7					result >> 7							  if instruction == 0xE8 { result := X + 1; newX := result; *X = newX; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xE8 ) { unsigned int result = X + 1; unsigned char newX = result; *X = newX; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xE8 ) { const result = X + 1; const newX = result; cpu.X = newX; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			carry, zero			SS E8	UNINX	$SS																														
E9 LL	SBC	2	#$LL								A - LL - (carry^1)	result					???	(result | -result) >> 7				???	result >> 7							  if instruction == 0xE9 { LL := memory[PC + 1]; result := A - LL - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xE9 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int result = A - LL - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xE9 ) { const LL = memory[(PC+1)&0xFFFF]; const result = A - LL - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ???;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }									???			E9	UNSBC																															
EA	NOP	2																												  if instruction == 0xEA { *PC = PC + 1; return true }		  if( instruction == 0xEA ) { *PC = PC + 1; return true; }		  if( instruction == 0xEA ) { cpu.PC = PC + 1; return true; }												EA	UNNOP																															
EC LL HH	CPX	3	$LLHH						HHLL		X - readByte						1 - (result >> 7)	(result | -result) >> 7					result >> 7							  if instruction == 0xEC { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := X - readByte; carry := 1 - (result >> 7);zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xEC ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = X - readByte; unsigned char carry = 1 - (result >> 7);unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xEC ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = X - readByte; const carry = 1 - (result >> 7);const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			carry, zero, negative			SS EC	UNCPX	$SS																														
ED LL HH	SBC	4	$HHLL						HHLL		A - readByte - (carry^1)	result					???	(result | -result) >> 7				???	result >> 7							  if instruction == 0xED { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xED ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xED ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ???;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }									???			ED	UNSBC																															
EE LL HH	INC	6	$HHLL						HHLL		readByte + 1							(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0xEE { LL := memory[PC + 1]; readByte := memory[(HHLL)&0xFFFF]; result := readByte + 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0xEE ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL)&0xFFFF]; unsigned int result = readByte + 1; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0xEE ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL)&0xFFFF]; const result = readByte + 1; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero			SS EE	UNINC	$SS																														
F0 LL	BEQ	2**	$LL													PC + 2 + (LL & (-zero))														  if instruction == 0xF0 { LL := memory[PC + 1]; newPC := PC + 2 + (LL & (-zero)); *PC = newPC; *PC = PC + 2 + (LL & (-zero));return true }		  if( instruction == 0xF0 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int newPC = (PC + 2 + (LL & (-zero)))&0xFFFF; *PC = newPC; *PC = PC + 2 + (LL & (-zero));return true; }		  if( instruction == 0xF0 ) { const LL = memory[(PC+1)&0xFFFF]; const newPC = (PC + 2 + (LL & (-zero)))&0xFFFF; cpu.PC = newPC; *PC = PC + 2 + (LL & (-zero));return true; }								PC				PP QQ F0	UNBEQ	$QQPP																														
F1	SBC	5*	($LL), Y					LL + X	zeroPageWord + Y		A - readByte - (carry^1)	result					???	(result | -result) >> 7				???	result >> 7							  if instruction == 0xF1 { zeroPageWord := memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); readByte := memory[(zeroPageWord + Y)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xF1 ) { unsigned int zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); unsigned char readByte = memory[(zeroPageWord + Y)&0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xF1 ) { const zeroPageWord = memory[(LL + X)&0xFF] + (memory[((LL + X)+1)&0xFF]<<8); const readByte = memory[(zeroPageWord + Y)&0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ???;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			???			SS F1	UNSBC	$SS																														
F5 LL	SBC	4	$LL, X						(LL + X) & 0xFF		A - readByte - (carry^1)	result					???	(result | -result) >> 7				???	result >> 7							  if instruction == 0xF5 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true }		  if( instruction == 0xF5 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; return true; }		  if( instruction == 0xF5 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ???;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; return true; }						SR			???			SS F5	UNSBC	$SS																														
F6 LL	INC	6	$LL, X						(LL + X) & 0xFF		readByte + 1							(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0xF6 { LL := memory[PC + 1]; readByte := memory[((LL + X) & 0xFF)&0xFFFF]; result := readByte + 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0xF6 ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned char readByte = memory[((LL + X) & 0xFF)&0xFFFF]; unsigned int result = readByte + 1; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0xF6 ) { const LL = memory[(PC+1)&0xFFFF]; const readByte = memory[((LL + X) & 0xFF)&0xFFFF]; const result = readByte + 1; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 2; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero			SS F6	UNINC	$SS																														
F8	SED	2																		0x1										  if instruction == 0xF8 { carry := SR&1; zero := (SR>>1)&1; interrupt := (SR>>2)&1; decimal := 0x1;overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xF8 ) { unsigned char carry = SR&1; unsigned char zero = (SR>>1)&1; unsigned char interrupt = (SR>>2)&1; unsigned char decimal = 0x1;unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xF8 ) { const carry = SR&1; const zero = (SR>>1)&1; const interrupt = (SR>>2)&1; const decimal = 0x1;const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			decimal			SS F8	UNSED	$SS																														
F9	SBC	4*	$HHLL, Y						HHLL + Y		A - readByte - (carry^1)	result					???	(result | -result) >> 7				???	result >> 7							  if instruction == 0xF9 { readByte := memory[(HHLL + Y)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true }		  if( instruction == 0xF9 ) { unsigned char readByte = memory[(HHLL + Y)&0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 1; return true; }		  if( instruction == 0xF9 ) { const readByte = memory[(HHLL + Y)&0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ???;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 1; return true; }						SR			???			SS F9	UNSBC	$SS																														
FD LL HH	SBC	4*	$HHLL, X						HHLL + X		A - readByte - (carry^1)	result					???	(result | -result) >> 7				???	result >> 7							  if instruction == 0xFD { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := A - readByte - (carry^1); newA := result; *A = newA; carry := ???;zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true }		  if( instruction == 0xFD ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = A - readByte - (carry^1); unsigned char newA = result; *A = newA; unsigned char carry = ???;unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = ???;*SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; return true; }		  if( instruction == 0xFD ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = A - readByte - (carry^1); const newA = result; cpu.A = newA; const carry = ???;const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = ???;cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; return true; }						SR			???			SS FD	UNSBC	$SS																														
FE LL HH	INC	7	$HHLL, X						HHLL + X		readByte + 1							(result | -result) >> 7					result >> 7	readByteAddress	result					  if instruction == 0xFE { LL := memory[PC + 1]; readByte := memory[(HHLL + X)&0xFFFF]; result := readByte + 1; carry := SR&1; zero := (result | -result) >> 7;interrupt := (SR>>2)&1; decimal := (SR>>3)&1; overflow := (SR>>6)&1; negative := (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true }		  if( instruction == 0xFE ) { unsigned char LL = memory[(PC+1)&0xFFFF]; unsigned int HH = memory[(PC+2)&0xFFFF]; unsigned int HHLL = LL + (HH<<8); unsigned char readByte = memory[(HHLL + X)&0xFFFF]; unsigned int result = readByte + 1; unsigned char carry = SR&1; unsigned char zero = (result | -result) >> 7;unsigned char interrupt = (SR>>2)&1; unsigned char decimal = (SR>>3)&1; unsigned char overflow = (SR>>6)&1; unsigned char negative = (SR>>7)&1; *SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); *PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }		  if( instruction == 0xFE ) { const LL = memory[(PC+1)&0xFFFF]; const HH = memory[(PC+2)&0xFFFF]; const HHLL = LL + (HH<<8); const readByte = memory[(HHLL + X)&0xFFFF]; const result = readByte + 1; const carry = SR&1; const zero = (result | -result) >> 7;const interrupt = (SR>>2)&1; const decimal = (SR>>3)&1; const overflow = (SR>>6)&1; const negative = (SR>>7)&1; cpu.SR = carry + (zero<<1) + (interrupt<<2) + (decimal<<3) + (overflow<<6) + (negative<<7); cpu.PC = PC + 3; memory[(readByteAddress)&0xFFFF] = result; return true; }						SR			carry, zero			SS FE	UNINC	$SS																														
																														  return false		  return false;		  return false																																												
																														}		}		}																																												